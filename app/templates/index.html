<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>OCPP Server UI</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <style>
        /* (unchanged styles trimmed for brevity) */
        body { font-family: Arial, sans-serif; background:#f4f4f4; margin:0; padding:20px; }
        .container { max-width:1400px; margin:auto; background:#fff; padding:20px; border-radius:8px; box-shadow:0 0 10px rgba(0,0,0,.1); }
        h1,h2 { color:#333; border-bottom:2px solid #eee; padding-bottom:10px; }
        .status-box { display:flex; justify-content:space-between; margin-bottom:20px; }
        .status-item { flex:1; padding:15px; margin:0 10px; background:#e9ecef; border-radius:8px; text-align:center; }
        .status-item h3 { margin-top:0; font-size:1em; text-align:center; }
        #charging-status { font-weight:bold; }
        .config-section { background:#e3f2fd; border:1px solid #90caf9; border-radius:8px; padding:15px; margin-bottom:20px; }
        .config-item { display:flex; align-items:center; gap:10px; margin-bottom:10px; }
        .config-item label { font-weight:bold; }
        .config-item select { padding:5px; border-radius:4px; border:1px solid #ccc; }
        .config-values { margin-top:10px; }
        .config-values p { margin:5px 0; font-weight:bold; }
        .button-group button:disabled { background:#6c757d; cursor:not-allowed; opacity:0.6; }
        .control-panel-grid { display:grid; grid-template-columns:1fr 1fr 1fr; gap:20px; margin-top:10px; }

        /* Wallbox Discovery Section */
        .wallbox-discovery-section { background:#f0f8f0; border:1px solid #90c695; border-radius:8px; padding:15px; margin-bottom:20px; }

        /* Wallbox Capabilities Section */
        .wallbox-capabilities-section { background:#e8f4fd; border:1px solid #64b5f6; border-radius:8px; padding:20px; margin-bottom:20px; }
        .capability-info { margin-bottom:20px; }
        .capability-info h3 { color:#1565c0; margin-top:0; }
        .capability-info ul { margin:10px 0; padding-left:20px; }
        .capability-info li { margin-bottom:8px; line-height:1.4; }

        .capability-status { background:#fff; border:1px solid #bbdefb; border-radius:6px; padding:15px; margin-bottom:20px; }
        .capability-status h4 { color:#1976d2; margin-top:0; margin-bottom:15px; }
        .status-indicator { display:flex; align-items:center; gap:10px; margin-bottom:10px; }
        .status-dot { width:12px; height:12px; border-radius:50%; display:inline-block; }
        .status-dot.waiting { background:#ffc107; animation:pulse 2s infinite; }
        .status-dot.connected { background:#28a745; }
        .status-dot.active { background:#17a2b8; }
        .status-dot.error { background:#dc3545; }

        .capability-action { text-align:center; }
        .capability-action h4 { color:#1976d2; margin-bottom:10px; }
        .quick-action { margin-top:15px; }
        .analysis-btn { background:#1976d2; color:white; border:none; padding:12px 24px; border-radius:6px; cursor:pointer; font-size:14px; font-weight:bold; }
        .analysis-btn:hover:not(:disabled) { background:#1565c0; }
        .analysis-btn:active:not(:disabled) { transform:translateY(1px); }
        .analysis-btn:disabled { background:#6c757d !important; cursor:not-allowed !important; opacity:0.6 !important; }
        .discovery-controls { display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; flex-wrap:wrap; gap:10px; }
        .autodiscovery-toggle label { display:flex; align-items:center; gap:8px; font-weight:bold; color:#2e7d32; }
        .active-wallbox { color:#1976d2; font-size:14px; }
        #active-wallbox-name { color:#d84315; font-weight:bold; }

        .discovered-wallboxes-list h4 { margin:0 0 10px 0; color:#2e7d32; }
        #wallboxes-container { display:flex; flex-direction:column; gap:8px; }
        .no-wallboxes { color:#666; font-style:italic; padding:10px; text-align:center; background:#fafafa; border-radius:4px; }

        .wallbox-item { display:flex; justify-content:space-between; align-items:center; padding:10px; background:#fff; border:1px solid #c8e6c9; border-radius:6px; }
        .wallbox-item.active { border-color:#4caf50; background:#e8f5e8; box-shadow:0 2px 4px rgba(76,175,80,0.2); }
        .wallbox-item.disconnected { border-color:#ff9800; background:#fff3e0; opacity:0.7; }

        .wallbox-info { display:flex; flex-direction:column; }
        .wallbox-name { font-weight:bold; color:#2e7d32; }
        .wallbox-details { font-size:12px; color:#666; margin-top:2px; }
        .wallbox-status { font-size:11px; padding:2px 6px; border-radius:10px; }
        .wallbox-status.connected { background:#c8e6c9; color:#2e7d32; }
        .wallbox-status.disconnected { background:#ffccbc; color:#d84315; }

        .wallbox-actions { display:flex; gap:8px; }
        .wallbox-actions button { padding:4px 8px; font-size:11px; border:none; border-radius:4px; cursor:pointer; }
        .select-btn { background:#4caf50; color:white; }
        .select-btn:hover { background:#45a049; }
        .select-btn:disabled { background:#cccccc; cursor:not-allowed; }
        .test-category { background:#f8f9fa; border:1px solid #dee2e6; border-radius:8px; padding:15px; }
        .button-group { display:flex; flex-wrap:wrap; gap:10px; }
        .button-group button { padding:10px 15px; font-size:14px; border:none; border-radius:5px; color:#fff; background:#007bff; cursor:pointer; }
        .button-group button.btn-success { background-color: #28a745; }
        .button-group button.btn-failure { background-color: #dc3545; }
        .button-group button.btn-running { background-color: #6c757d; cursor: wait; }
        .button-group button.btn-skipped { background-color: #ffc107; color: #000; }
        .button-group button.btn-partial { background-color: #fd7e14; }
        .button-group button.btn-not-supported { background-color: #6c757d; }
        .button-group button.active-state { background-color: #28a745; }
        .button-group button.disabled { background:#6c757d; cursor:not-allowed; }
        .log-container { height:400px; overflow-y:scroll; border:1px solid #ccc; padding:10px; background:#f8f9fa; border-radius:8px; margin-top:20px; font-family:'Courier New', Courier, monospace; font-size:14px; }
        .log-line { white-space:pre-wrap; word-wrap:break-word; margin-bottom:5px; }
        .log-line.info { color:#007bff; } .log-line.error { color:#dc3545; font-weight:bold; } .log-line.warning { color:#ffc107; } .log-line.debug { color:#6c757d; }
    .wallbox-button.selected {
            background-color: #0056b3; /* A darker blue to indicate selection */
            border: 1px solid #0056b3;
        }
            .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgb(0,0,0); /* Fallback color */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto; /* 15% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%; /* Could be more or less, depending on screen size */
            max-width: 500px;
            border-radius: 8px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }

        /* Verification Results Modal */
        .verification-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .verification-table th,
        .verification-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .verification-table th {
            background-color: #f0f0f0;
            font-weight: bold;
            color: #333;
        }

        .verification-table tr:hover {
            background-color: #f9f9f9;
        }

        .verification-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 4px 12px;
            border-radius: 4px;
            font-weight: bold;
        }

        .verification-status.ok {
            background-color: #d4edda;
            color: #155724;
        }

        .verification-status.not-ok {
            background-color: #f8d7da;
            color: #721c24;
        }

        .verification-status.info {
            background-color: #e7f3ff;
            color: #004085;
        }

        .verification-icon {
            font-size: 18px;
        }

        /* B.1 Warning Popup */
        #b1WarningPopup {
            display: none;
            position: fixed;
            z-index: 9999;
            background: linear-gradient(135deg, #fff5e6 0%, #fff 100%);
            border: 3px solid #ff6b6b;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(255, 107, 107, 0.4);
            max-width: 450px;
            animation: popupSlideIn 0.3s ease-out;
        }

        @keyframes popupSlideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        #b1WarningPopup::before {
            content: '‚ö†Ô∏è';
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 40px;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-5px); }
        }

        #b1WarningPopup .popup-header {
            font-size: 18px;
            font-weight: bold;
            color: #d32f2f;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #ffcdd2;
            padding-bottom: 10px;
        }

        #b1WarningPopup .popup-content {
            color: #333;
            line-height: 1.6;
            margin-bottom: 20px;
            font-size: 15px;
        }

        #b1WarningPopup .popup-button {
            width: 100%;
            padding: 12px;
            background: #d32f2f;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }

        #b1WarningPopup .popup-button:hover {
            background: #b71c1c;
        }

        #b1WarningPopup .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
            display: none;
        }
</style>
</head>
<body>
<div class="container">
    <h1>OCPP Server Status</h1>

    <h2>Discovered Wallboxes</h2>
    <div class="wallbox-discovery-section">
        <div class="discovery-controls">
            <div class="active-wallbox">
                <strong>Active Wallbox:</strong> <span id="active-wallbox-name">Loading...</span>
            </div>
        </div>

        <div class="discovered-wallboxes-list">
            <div id="wallboxes-container">
            </div>
        </div>

        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #c8e6c9; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap;">
            <div style="display: flex; align-items: center; gap: 20px;">
                <div>
                    <strong>Mode:</strong>
                    <span id="current-mode" style="font-weight: bold; color: #2e7d32;">{{ initial_mode }}</span>
                </div>
                <div>
                    <strong>Transaction ID:</strong>
                    <span id="active-transaction-id-display" style="font-weight: bold; color: #1976d2;">N/A</span>
                </div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button id="reboot-wallbox-button" class="button" style="background-color: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;" onclick="rebootWallbox()">Reboot Wallbox</button>
                <button id="shutdown-server-button" class="button" style="background-color: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;">Shutdown Server</button>
            </div>
        </div>
    </div>

    <h2>Charger Information</h2>
    <div class="charger-information-section wallbox-capabilities-section" style="display: flex; flex-direction: row; gap: 20px; flex-wrap: wrap; min-width: 600px;">
                    <div class="capability-info" style="flex: 1; width: 100%;">
                        <h3>Charger Info Data</h3>
                        <div style="font-size: 15px; line-height: 1.3;">
                            <div style="margin-bottom: 4px; padding: 2px 0; border-bottom: 1px solid #f0f0f0;">
                                <span style="font-weight: bold; color: #333; display: inline-block; width: 160px; font-size: 15px;">Vendor:</span>
                                <span style="color: #666; font-size: 15px;" id="vendor">N/A</span>
                            </div>
                            <div style="margin-bottom: 4px; padding: 2px 0; border-bottom: 1px solid #f0f0f0;">
                                <span style="font-weight: bold; color: #333; display: inline-block; width: 160px; font-size: 15px;">Model:</span>
                                <span style="color: #666; font-size: 15px;" id="model">N/A</span>
                            </div>
                            <div style="margin-bottom: 4px; padding: 2px 0; border-bottom: 1px solid #f0f0f0;">
                                <span style="font-weight: bold; color: #333; display: inline-block; width: 160px; font-size: 15px;">First Contact:</span>
                                <span style="color: #666; font-size: 15px;" id="first-status-time">N/A</span>
                            </div>
                            <div style="margin-bottom: 4px; padding: 2px 0; border-bottom: 1px solid #f0f0f0;">
                                <span style="font-weight: bold; color: #333; display: inline-block; width: 160px; font-size: 15px;">Server Boot Time:</span>
                                <span style="color: #666; font-size: 15px;" id="boot-time">N/A</span>
                            </div>
                            <div style="margin-bottom: 4px; padding: 2px 0; border-bottom: 1px solid #f0f0f0;">
                                <span style="font-weight: bold; color: #333; display: inline-block; width: 160px; font-size: 15px;">Status:</span>
                                <span style="color: #666; font-size: 15px;" id="charging-status">N/A</span>
                            </div>
                            <div style="margin-bottom: 4px; padding: 2px 0; border-bottom: 1px solid #f0f0f0;">
                                <span style="font-weight: bold; color: #333; display: inline-block; width: 160px; font-size: 15px;">Current Charging:</span>
                                <span style="color: #666; font-size: 15px;" id="current-charging">0 W / 0 A</span>
                            </div>
                            <div style="margin-bottom: 4px; padding: 2px 0; border-bottom: 1px solid #f0f0f0;">
                                <span style="font-weight: bold; color: #333; display: inline-block; width: 160px; font-size: 15px;">Last Heartbeat:</span>
                                <span style="color: #666; font-size: 15px;" id="last-heartbeat">N/A</span>
                            </div>
                        </div>
                    </div>
                    <div class="capability-info" style="flex: 1; width: 100%;">
                        <h3>Parameter Info</h3>
                        <div id="a3-test-results-content">No A.3 test results available.</div>
                    </div>    </div>
    <div class="quick-actions-container" style="display: flex; justify-content: space-around; margin-top: 15px;">
        <div class="quick-action">
            <button onclick="runTestWithParams('run_a3_change_configuration_test', {})" class="analysis-btn">
                A.3: Get OCPP Standard Keys
            </button>
        </div>
    </div>

    <h2>Wallbox offers to EV</h2>
    <div class="wallbox-capabilities-section">
        <div class="capability-info">
            <div id="meter-values-display" style="display: flex; font-family: monospace; background: #fff; border: 1px solid #ddd; padding: 15px; border-radius: 6px; margin: 15px 0;">
                <div id="meter-values-content" style="flex: 1;">Waiting for MeterValues data...</div>
                <div id="composite-schedule-display" style="flex: 1; padding-left: 15px; border-left: 1px solid #ddd;">
                    <h4>Composite Schedule</h4>
                    <div id="composite-schedule-content"></div>
                </div>
            </div>
        </div>
        <div class="quick-actions-container" style="display: flex; justify-content: space-around; margin-top: 15px;">
            <div class="quick-action">
                <button onclick="runTestWithParams('run_c3_get_composite_schedule_test', {})" class="analysis-btn">
                    C.3: GetCompositeSchedule
                </button>
            </div>
        </div>
    </div>

    <h2>Control Panel</h2>
    <div class="control-panel-grid">
        <div class="test-category">
            <h3>A. Core Communication & Status</h3>
            <div class="button-group" id="category-a-buttons">
                <button data-step-key="run_a1_change_configuration_test">A.1: ChangeConfiguration</button>
                <button data-step-key="run_a2_get_configuration_test">A.2: Get All Configuration</button>
            </div>
        </div>
        <div class="test-category">
            <h3>B. Authorization & Transaction Management</h3>
            <div class="button-group" id="category-b-buttons">
                <button data-step-key="run_b1_reset_transaction_management">B.1: Reset Transaction Management</button>
                <button data-step-key="run_b2_autonomous_start_test">B.2: Autonomous Start</button>
                <button data-step-key="run_b6_clear_rfid_cache">B.6: Clear RFID Cache</button>
                <button data-step-key="run_b7_send_rfid_list">B.7: Send RFID List</button>
                <button data-step-key="run_b8_get_rfid_list_version">B.8: Get RFID List Version</button>
                <button data-step-key="run_b3_tap_to_charge_test">B.3: RFID Tap-to-Charge</button>
                <button data-step-key="run_b4_anonymous_remote_start_test">B.4: Anonymous Remote Start</button>
                <button data-step-key="run_b5_plug_and_charge_test">B.5: Plug-and-Charge</button>
            </div>
        </div>
        <div class="test-category">
            <h3>C. Smart Charging Profile</h3>
            <div class="button-group" id="category-c-buttons">
            </div>
        </div>
    </div>

    <h2>System Control</h2>
    <div class="test-category" style="margin-bottom: 20px;">
        <div class="button-group" id="category-x-buttons">
            <!-- Dynamic X.1, X.2, and Clear Test Results buttons will be inserted here -->
        </div>
    </div>
    <div id="status-message" class="status-message" style="display:none;"></div>

    <h2 id="ev-simulator-heading">EV Simulator Status</h2>
    <div id="ev-info" style="display:none; gap:20px;">
        <div id="ev-status-details" style="flex:1;">
            <p><strong>EV State:</strong> <span id="ev-state">N/A</span></p>
            <p><strong>Wallbox Advertised Current:</strong> <span id="ev-wallbox-current">N/A</span></p>
            <p><strong>CP Voltage:</strong> <span id="ev-voltage">N/A</span></p>
            <p><strong>CP Duty Cycle:</strong> <span id="ev-duty-cycle">N/A</span></p>
            <p><strong>PP Voltage:</strong> <span id="ev-pp-voltage">N/A</span></p>
            <p><strong>Error Status:</strong> <span id="ev-error">N/A</span></p>
        </div>
        <div class="button-group" style="flex:2; align-self:center;">
            <button id="btn-state-a" onclick="setEvState('A')">Set State A (Disconnected)</button>
            <button id="btn-state-b" onclick="setEvState('B')">Set State B (Connected)</button>
            <button id="btn-state-c" onclick="setEvState('C')">Set State C (Charging)</button>
            <button id="btn-state-e" onclick="setEvState('E')">Set State E (Error)</button>
        </div>
    </div>

    <h2>Logs</h2>
    <div class="log-container" id="log-output"></div>
</div>

<div id="chargingProfileModal" class="modal">
  <!-- Modal content -->
  <div class="modal-content">
    <span class="close" id="modal-close-button">&times;</span>
    <h3 id="modal-title">Set Charging Profile</h3>
    <form id="chargingProfileForm">
        <input type="hidden" id="modal-step-key" />
        <div class="form-group">
            <label for="stackLevel">Stack Level</label>
            <input type="number" id="stackLevel" name="stackLevel" value="0">
        </div>
        <div class="form-group" id="purpose-form-group">
            <label for="chargingProfilePurpose">Profile Purpose</label>
            <select id="chargingProfilePurpose" name="chargingProfilePurpose">
                <option value="ChargePointMaxProfile">ChargePointMaxProfile</option>
                <option value="TxDefaultProfile">TxDefaultProfile</option>
                <option value="TxProfile">TxProfile</option>
            </select>
        </div>
        <div class="form-group" id="kind-form-group">
            <label for="chargingProfileKind">Profile Kind</label>
            <select id="chargingProfileKind" name="chargingProfileKind">
                <option value="Absolute">Absolute</option>
                <option value="Recurring">Recurring</option>
                <option value="Relative">Relative</option>
            </select>
        </div>
        <div class="form-group" id="unit-form-group">
            <label for="chargingRateUnit">Charging Rate Unit</label>
            <select id="chargingRateUnit" name="chargingRateUnit">
                <option value="A">A (Amperes)</option>
                <option value="W">W (Watts)</option>
            </select>
        </div>
        <div class="form-group">
            <label for="limit">Limit</label>
            <input type="number" id="limit" name="limit" value="0">
        </div>
        <div class="form-group">
            <label for="numberPhases">Number of Phases</label>
            <select id="numberPhases" name="numberPhases">
                <option value="1">1 (Single Phase)</option>
                <option value="3" selected>3 (Three Phase)</option>
            </select>
            <small>Most installations use 3-phase power</small>
        </div>
        <div class="form-group" id="duration-form-group">
            <label for="duration">Duration (seconds)</label>
            <input type="number" id="duration" name="duration" value="3600">
        </div>
        <button type="submit">Run Test</button>
    </form>
  </div>
</div>

<!-- GetCompositeSchedule Modal -->
<div id="compositeScheduleModal" class="modal">
  <div class="modal-content">
    <span class="close" id="composite-modal-close-button">&times;</span>
    <h3>C.3: GetCompositeSchedule</h3>
    <form id="compositeScheduleForm">
        <div class="form-group">
            <label for="composite-connectorId">Connector ID</label>
            <input type="number" id="composite-connectorId" name="connectorId" value="1" min="0">
            <small>0 = Charge Point, 1+ = Specific Connector</small>
        </div>
        <div class="form-group">
            <label for="composite-duration">Duration (seconds)</label>
            <input type="number" id="composite-duration" name="duration" value="3600" min="1">
            <small>Default: 3600 (1 hour). Use 86400 for full day schedule.</small>
        </div>
        <div class="form-group">
            <label for="composite-chargingRateUnit">Charging Rate Unit</label>
            <select id="composite-chargingRateUnit" name="chargingRateUnit">
                <option value="">Auto-detect from wallbox</option>
                <option value="A">A (Amperes)</option>
                <option value="W">W (Watts)</option>
            </select>
            <small>Leave empty to auto-detect from wallbox configuration.</small>
        </div>
        <button type="submit">Get Composite Schedule</button>
    </form>
  </div>
</div>

<!-- RFID Authorization Modal -->
<div id="rfidModal" class="modal">
  <div class="modal-content">
    <span class="close" id="rfid-modal-close">&times;</span>
    <h3>üé´ RFID Authorization Test</h3>
    <div id="rfid-status">
        <p><strong>Instructions:</strong></p>
        <ol>
            <li>üìò Present the <strong>FIRST</strong> RFID card to the wallbox reader (will be <span style="color: #28a745;">ACCEPTED</span>)</li>
            <li>üìò Then present a <strong>DIFFERENT</strong> RFID card to the wallbox reader (will be <span style="color: #dc3545;">INVALID</span>)</li>
            <li>üí° <strong>Important:</strong> Use different cards - the wallbox may not re-read the same card immediately</li>
        </ol>
        <div id="rfid-progress" style="margin: 20px 0;">
            <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 15px;">
                <div id="rfid-timer" style="font-weight: bold; color: #007bff;">‚è≥ Waiting for test to start...</div>
                <div id="rfid-cards-status" style="margin-top: 10px;">
                    <div id="card1-status" style="margin: 5px 0; padding: 8px; border-radius: 4px; background-color: #e9ecef;">
                        üìá Card 1: <span id="card1-result">Waiting...</span>
                    </div>
                    <div id="card2-status" style="margin: 5px 0; padding: 8px; border-radius: 4px; background-color: #e9ecef;">
                        üìá Card 2: <span id="card2-result">Waiting...</span>
                    </div>
                </div>
            </div>
        </div>
        <div id="rfid-log" style="max-height: 200px; overflow-y: auto; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; font-family: monospace; font-size: 12px;">
            <div>üìù Authorization log will appear here...</div>
        </div>
    </div>
    <div style="margin-top: 20px;">
        <button id="rfid-close-btn" class="button" style="background-color: #6c757d; color: white; padding: 8px 16px; border: none; border-radius: 4px;">Close</button>
    </div>
  </div>
</div>

<!-- B.3 RFID Tap-to-Charge Modal -->
<div id="tapToChargeModal" class="modal">
  <div class="modal-content">
    <span class="close" id="tap-to-charge-modal-close">&times;</span>
    <h3>üé´ B.3: RFID Tap-to-Charge Test</h3>
    <div id="tap-to-charge-status">
        <div style="margin: 30px 0; text-align: center;">
            <div style="font-size: 48px; margin-bottom: 20px;">üé´</div>
            <div id="tap-to-charge-timer" style="font-weight: bold; color: #007bff; font-size: 20px; margin-bottom: 20px;">
                ‚è≥ Please present your RFID card to the wallbox
            </div>
            <div id="tap-to-charge-countdown" style="font-size: 16px; color: #6c757d;">
                Time remaining: 60s
            </div>
        </div>
    </div>
  </div>
</div>

<!-- B.4 Anonymous Remote Start Modal -->
<div id="remoteStartModal" class="modal">
  <div class="modal-content">
    <span class="close" id="remote-start-modal-close">&times;</span>
    <h3>üì± B.4: Anonymous Remote Start</h3>
    <div style="padding: 20px;">
      <p style="margin-bottom: 20px; color: #666; font-size: 16px;">
        This simulates <strong>free charging</strong> or charging where payment is handled externally.<br>
        The Central System will send a <strong>RemoteStartTransaction</strong> command <strong>without an ID tag</strong>.
      </p>
      <p style="margin-bottom: 20px; color: #444;">
        <strong>Use cases:</strong>
      </p>
      <ul style="margin-bottom: 20px; color: #666;">
        <li>Free public charging</li>
        <li>One-time credit card payment on website</li>
        <li>Pre-paid charging sessions</li>
      </ul>
      <form id="remoteStartForm">
        <div style="margin-top: 20px;">
          <button type="submit" class="button" style="background-color: #28a745; color: white; padding: 10px 20px; border: none; border-radius: 4px; margin-right: 10px; font-size: 16px;">
            üöó Start Anonymous Charging
          </button>
          <button type="button" id="remote-start-cancel-btn" class="button" style="background-color: #6c757d; color: white; padding: 10px 20px; border: none; border-radius: 4px; font-size: 16px;">
            Cancel
          </button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Verification Results Modal -->
<div id="verificationResultsModal" class="modal">
  <div class="modal-content">
    <span class="close" id="verification-modal-close">&times;</span>
    <h3 id="verification-modal-title">Verification Results</h3>
    <div id="verification-results-content">
      <table class="verification-table">
        <thead>
          <tr>
            <th>Parameter</th>
            <th>Expected</th>
            <th>Actual</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="verification-table-body">
          <!-- Rows will be populated dynamically -->
        </tbody>
      </table>
    </div>
    <div style="text-align: center; margin-top: 20px;">
      <button type="button" id="verification-ok-btn" class="button" style="background-color: #007bff; color: white; padding: 10px 30px; border: none; border-radius: 4px; font-size: 16px;">
        OK
      </button>
    </div>
  </div>
</div>

<!-- B.1 Warning Popup Overlay -->
<div id="b1WarningOverlay" style="display: none; position: fixed: top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.6); z-index: 9998;"></div>

<!-- B.1 Warning Popup -->
<div id="b1WarningPopup" style="display: none;">
    <div class="popup-header">
        ‚ö†Ô∏è  TEST CANNOT PROCEED
    </div>
    <div class="popup-content" id="b1WarningContent">
        Wallbox has offline authorization enabled and auto-started a transaction.
    </div>
    <button class="popup-button" onclick="closeB1Warning()">ACKNOWLEDGE</button>
</div>

<script>
    const chargingStatusEl = document.getElementById("charging-status");
    const currentChargingEl = document.getElementById("current-charging");
    const shutdownServerButton = document.getElementById("shutdown-server-button");
    const vendorEl = document.getElementById("vendor");
    const modelEl = document.getElementById("model");
    const firstStatusTimeEl = document.getElementById("first-status-time");
    const bootTimeEl = document.getElementById("boot-time");
    const lastHeartbeatEl = document.getElementById("last-heartbeat");
    const statusMessageEl = document.getElementById("status-message");
    const logOutputEl = document.getElementById("log-output");
    const activeTransactionIdDisplay = document.getElementById("active-transaction-id-display");

    const evStateEl = document.getElementById("ev-state");
    const evVoltageEl = document.getElementById("ev-voltage");
    const evErrorEl = document.getElementById("ev-error");
    const evWallboxCurrentEl = document.getElementById("ev-wallbox-current");
    const evDutyCycleEl = document.getElementById("ev-duty-cycle");
    const evPpVoltageEl = document.getElementById("ev-pp-voltage");

    const WS_PORT = {{ ocpp_port }};

    let chargePointsData = {};
    let transactionsData = {};
    let isConnected = false;
    let useSimulator = false;
    let serverSettings = {};
    let activeTestKey = null;  // Track which test is currently running

    // B.1 Warning Popup Functions
    function showB1Warning(message, buttonElement) {
        const popup = document.getElementById('b1WarningPopup');
        const overlay = document.getElementById('b1WarningOverlay');
        const content = document.getElementById('b1WarningContent');

        // Set the message content
        content.textContent = message;

        // Show overlay
        overlay.style.display = 'block';

        // Show popup
        popup.style.display = 'block';

        // Position popup near the button
        if (buttonElement) {
            const rect = buttonElement.getBoundingClientRect();

            // Position popup to the right and slightly below the button (fixed positioning = relative to viewport)
            let topPosition = rect.bottom + 10;
            let leftPosition = rect.left;

            // Adjust if popup would go off-screen
            const popupWidth = 450; // max-width from CSS
            if (leftPosition + popupWidth > window.innerWidth) {
                leftPosition = window.innerWidth - popupWidth - 20;
            }

            // Ensure it doesn't go below the viewport
            if (topPosition + 300 > window.innerHeight) {
                topPosition = rect.top - 310;  // Show above button instead
            }

            popup.style.top = topPosition + 'px';
            popup.style.left = leftPosition + 'px';
            popup.style.transform = 'none';  // Clear any previous transform
        } else {
            // Center if no button reference
            popup.style.top = '50%';
            popup.style.left = '50%';
            popup.style.transform = 'translate(-50%, -50%)';
        }
    }

    function closeB1Warning() {
        const popup = document.getElementById('b1WarningPopup');
        const overlay = document.getElementById('b1WarningOverlay');

        popup.style.display = 'none';
        overlay.style.display = 'none';
    }

    // Verification Results Modal Functions
    function showVerificationResults(title, results) {
        console.log(`üéØ DEBUG: showVerificationResults called with title="${title}", results=`, results);
        const modal = document.getElementById('verificationResultsModal');
        const modalTitle = document.getElementById('verification-modal-title');
        const tableBody = document.getElementById('verification-table-body');

        console.log(`üéØ DEBUG: Modal element:`, modal);
        console.log(`üéØ DEBUG: Modal title element:`, modalTitle);
        console.log(`üéØ DEBUG: Table body element:`, tableBody);

        // Set title
        modalTitle.textContent = title;
        console.log(`üéØ DEBUG: Set modal title to "${title}"`);

        // Clear existing rows
        tableBody.innerHTML = '';
        console.log(`üéØ DEBUG: Cleared table body`);

        // Add rows for each result
        console.log(`üéØ DEBUG: Processing ${results.length} results...`);
        results.forEach(result => {
            const row = document.createElement('tr');

            let statusClass, statusIcon;
            if (result.status === 'OK') {
                statusClass = 'ok';
                statusIcon = '‚úì';
            } else if (result.status === 'INFO') {
                statusClass = 'info';
                statusIcon = '‚Ñπ';
            } else {
                statusClass = 'not-ok';
                statusIcon = '‚úó';
            }

            row.innerHTML = `
                <td>${result.parameter}</td>
                <td>${result.expected}</td>
                <td>${result.actual}</td>
                <td>
                    <span class="verification-status ${statusClass}">
                        <span class="verification-icon">${statusIcon}</span>
                        ${result.status}
                    </span>
                </td>
            `;
            tableBody.appendChild(row);
            console.log(`üéØ DEBUG: Added row for ${result.parameter}`);
        });

        // Show modal
        console.log(`üéØ DEBUG: Setting modal display to 'block'`);
        modal.style.display = 'block';
        console.log(`üéØ DEBUG: Modal should now be visible!`);
    }

    function closeVerificationModal() {
        const modal = document.getElementById('verificationResultsModal');
        modal.style.display = 'none';
    }

    function showStatusMessage(message, isError = false) {
        statusMessageEl.textContent = message;
        statusMessageEl.className = `status-message ${isError ? 'error' : 'success'}`;
        statusMessageEl.style.display = 'block';
        setTimeout(() => statusMessageEl.style.display = 'none', 5000);
    }

    function updateChargePointDetails(cpId) {
        const cp = chargePointsData[cpId];
        console.log('updateChargePointDetails - cp:', cp); // Added for debugging
        if (cp) {
            vendorEl.textContent = cp.vendor || 'N/A';
            modelEl.textContent = cp.model || 'N/A';
            firstStatusTimeEl.textContent = cp.first_status_time ? new Date(cp.first_status_time).toLocaleString() : 'N/A';
            bootTimeEl.textContent = cp.boot_time ? new Date(cp.boot_time).toLocaleString() : 'N/A';
            chargingStatusEl.textContent = cp.status || 'N/A';
            const powerW = cp.current_power_w || 0;
            const currentA = cp.current_current_a || 0;
            currentChargingEl.textContent = `${powerW.toFixed(0)} W / ${currentA.toFixed(1)} A`;
            lastHeartbeatEl.textContent = cp.last_heartbeat ? new Date(cp.last_heartbeat).toLocaleString() : 'N/A';

            // Enable all test buttons when wallbox is connected
            document.querySelectorAll('.test-category .button-group button').forEach(btn => {
                btn.classList.remove('disabled');
            });

            // Enable all analysis buttons (quick action buttons)
            document.querySelectorAll('.analysis-btn').forEach(btn => {
                btn.disabled = false;
            });
            const testResults = cp.test_results || {};
            document.querySelectorAll('[data-step-key]').forEach(btn => {
                const stepKey = btn.dataset.stepKey;
                const result = testResults[stepKey];

                // Only update colors if button is not currently running a test
                // Check both the CSS class AND the activeTestKey flag for extra protection
                const isRunning = btn.classList.contains('btn-running');
                const isActiveTest = (typeof activeTestKey !== 'undefined' && stepKey === activeTestKey);

                if (!isRunning && !isActiveTest) {
                    btn.classList.remove('btn-success', 'btn-failure', 'btn-skipped', 'btn-partial', 'btn-not-supported');
                    if (result === 'PASSED') {
                        btn.classList.add('btn-success');
                    } else if (result === 'FAILED') {
                        btn.classList.add('btn-failure');
                    } else if (result === 'SKIPPED') {
                        btn.classList.add('btn-skipped');
                    } else if (result === 'PARTIAL') {
                        btn.classList.add('btn-partial');
                    } else if (result === 'NOT_SUPPORTED') {
                        btn.classList.add('btn-not-supported');
                    }
                }
            });

            // Restore composite schedule update logic
            const scheduleContainer = document.getElementById('composite-schedule-content');
            if (cp.composite_schedule && cp.composite_schedule.chargingSchedulePeriod) {
                let scheduleHtml = `<ul>`;
                cp.composite_schedule.chargingSchedulePeriod.forEach((period, index) => {
                    scheduleHtml += `<li>Period ${index + 1}: Start ${period.startPeriod}s, Limit ${period.limit}${cp.composite_schedule.chargingRateUnit}, Phases ${period.numberPhases || 'N/A'}</li>`;
                });
                scheduleHtml += `</ul>`;
                scheduleContainer.innerHTML = scheduleHtml;
            } else {
                scheduleContainer.innerHTML = 'No schedule data available.';
            }

            // Update A.3 Configuration Details - Show all configuration parameters
            const a3TestResultsContent = document.getElementById('a3-test-results-content');

            // Use configuration_details instead of test_results for parameter values
            const a3Results = cp.configuration_details;
            console.log('Configuration details:', a3Results);

            if (a3Results && typeof a3Results === 'object') {
                console.log('A3 Results found:', Object.keys(a3Results).length, 'parameters');
                console.log('First 5 keys:', Object.keys(a3Results).slice(0, 5));
                console.log('First 5 values:', Object.values(a3Results).slice(0, 5));

                // Preserve scroll position
                const currentScrollableDiv = a3TestResultsContent.querySelector('div[style*="overflow-y: auto"]');
                const currentScrollTop = currentScrollableDiv ? currentScrollableDiv.scrollTop : 0;

                let resultsHtml = '<div id="config-scrollable-container" style="max-height: 400px; overflow-y: auto; font-size: 15px; line-height: 1.3;">';

                // Sort parameters alphabetically for better readability
                const sortedKeys = Object.keys(a3Results).sort();
                let hasContent = false;

                for (const key of sortedKeys) {
                    const value = a3Results[key];

                    // Convert to string to ensure we can check content
                    const valueStr = String(value);

                    // Skip N/A and unsupported parameters - only show available ones
                    if (valueStr === 'N/A' || valueStr === 'N/A (Not Supported)' || valueStr === 'NO_RESPONSE') {
                        continue;
                    }

                    hasContent = true;
                    let displayValue = valueStr;
                    let isReadOnly = valueStr.includes('(RO)');

                    resultsHtml += '<div style="margin-bottom: 4px; padding: 2px 0; border-bottom: 1px solid #f0f0f0;">';

                    // Parameter name and value on same line for compactness
                    resultsHtml += '<div>';

                    // Parameter name
                    resultsHtml += '<span style="font-weight: bold; color: #333; display: inline-block; width: 340px; font-size: 15px;">';
                    resultsHtml += String(key) + ':';
                    resultsHtml += '</span>';

                    // Parameter value
                    resultsHtml += '<span style="color: #666; font-size: 15px;">';
                    resultsHtml += displayValue;
                    resultsHtml += '</span>';

                    resultsHtml += '</div>';
                    resultsHtml += '</div>';
                }

                if (!hasContent) {
                    // If no content after filtering, show all parameters including N/A for debugging
                    resultsHtml += '<div style="padding: 10px; color: #666;">Showing all parameters (including unsupported):</div>';

                    for (const key of sortedKeys) {
                        const value = a3Results[key];
                        const valueStr = String(value);

                        resultsHtml += '<div style="margin-bottom: 4px; padding: 2px 0; font-size: 12px;">';
                        resultsHtml += '<span style="font-weight: bold; color: #555; display: inline-block; min-width: 300px;">' + String(key) + ':</span>';
                        resultsHtml += '<span style="color: #888;">' + valueStr + '</span>';
                        resultsHtml += '</div>';
                    }
                } else {
                    console.log('Displayed parameters with values');
                }

                resultsHtml += '</div>';
                a3TestResultsContent.innerHTML = resultsHtml;

                // Restore scroll position after updating content
                const newScrollableDiv = document.getElementById('config-scrollable-container');
                if (newScrollableDiv && currentScrollTop > 0) {
                    newScrollableDiv.scrollTop = currentScrollTop;
                }
            } else {
                a3TestResultsContent.innerHTML = 'No configuration data available. Run A.3 test to retrieve all parameters.';
            }

        } else {
            ['vendor', 'model', 'first-status-time', 'boot-time', 'charging-status', 'last-heartbeat'].forEach(id => document.getElementById(id).textContent = 'N/A');
            currentChargingEl.textContent = '0 W / 0.0 A';

            // Disable all test buttons when no wallbox is connected
            document.querySelectorAll('.test-category .button-group button').forEach(btn => {
                btn.classList.add('disabled');
                btn.classList.remove('btn-success', 'btn-failure', 'btn-skipped', 'btn-partial', 'btn-not-supported');
            });

            // Also disable all analysis buttons (quick action buttons)
            document.querySelectorAll('.analysis-btn').forEach(btn => {
                btn.disabled = true;
            });
        }
    }

    async function fetchChargePoints() {
        try {
            const r = await fetch('/api/charge_points');
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const responseData = await r.json();
            chargePointsData = responseData.charge_points;
            const activeCpId = responseData.active_charge_point_id;
            const activeTxId = responseData.active_transaction_id;
            const ids = Object.keys(chargePointsData);
            if (ids.length > 0 && activeCpId) {
                updateChargePointDetails(activeCpId);
                activeTransactionIdDisplay.textContent = activeTxId !== null ? activeTxId : 'N/A';
            } else {
                // No active wallbox - disable all buttons
                updateChargePointDetails(null);
            }
        } catch (e) {
            console.error(e);
        }
    }

    async function fetchTransactions() {
        try {
            const r = await fetch('/api/transactions');
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const responseData = await r.json();
            transactionsData = responseData.transactions;
            window.transactionsData = transactionsData;
        } catch (e) {
            console.error('Error fetching transactions:', e);
        }
    }

    async function openChargingProfileModal(stepKey) {
        const modal = document.getElementById('chargingProfileModal');
        const modalTitle = document.getElementById('modal-title');
        const stepKeyInput = document.getElementById('modal-step-key');
        const form = document.getElementById('chargingProfileForm');
        const purposeSelect = form.chargingProfilePurpose;

        stepKeyInput.value = stepKey;

        // Show all fields and options by default
        document.getElementById('purpose-form-group').style.display = 'block';
        document.getElementById('duration-form-group').style.display = 'block';
        for (let i = 0; i < purposeSelect.options.length; i++) {
            purposeSelect.options[i].style.display = "";
        }

        // Fetch charging profile defaults from server
        let defaults = null;
        try {
            const response = await fetch('/api/charging_profile_defaults');
            if (response.ok) {
                defaults = await response.json();
            }
        } catch (error) {
            console.error('Failed to fetch charging profile defaults:', error);
        }

        // Set defaults based on the test case
        if (stepKey === 'run_c1_set_charging_profile_test') {
            modalTitle.textContent = 'C.1: SetChargingProfile';
            form.stackLevel.value = 0;
            form.chargingProfilePurpose.value = 'TxProfile';
            form.chargingProfileKind.value = 'Absolute';
            form.chargingRateUnit.value = defaults ? defaults.c1.unit : 'A';
            form.limit.value = defaults ? defaults.c1.limit : 0;
            form.numberPhases.value = 3;
            form.duration.value = 3600;

            for (let i = 0; i < purposeSelect.options.length; i++) {
                if (purposeSelect.options[i].value === 'TxDefaultProfile') {
                    purposeSelect.options[i].style.display = "none";
                }
            }

        } else if (stepKey === 'run_c2_tx_default_profile_test') {
            modalTitle.textContent = 'C.2: TxDefaultProfile';
            form.stackLevel.value = 0;
            form.chargingProfilePurpose.value = 'TxDefaultProfile';
            form.chargingProfileKind.value = 'Absolute';
            form.chargingRateUnit.value = defaults ? defaults.c2.unit : 'A';
            form.limit.value = defaults ? defaults.c2.limit : 60;
            form.numberPhases.value = 3;

            document.getElementById('purpose-form-group').style.display = 'none';
            document.getElementById('duration-form-group').style.display = 'none';
        }

        modal.style.display = 'block';
    }

    function openCompositeScheduleModal() {
        const modal = document.getElementById('compositeScheduleModal');
        modal.style.display = 'block';
    }

    async function runTestWithParams(stepKey, params) {
        const btn = document.querySelector(`[data-step-key='${stepKey}']`);

        // Remove any previous result colors and show running state
        btn.classList.remove('btn-success', 'btn-failure', 'btn-skipped', 'btn-partial', 'btn-not-supported');
        btn.classList.add('btn-running', 'disabled');
        activeTestKey = stepKey;  // Mark this test as active

        // Disable other buttons during test
        document.querySelectorAll('.test-category .button-group button').forEach(otherBtn => {
            if (otherBtn !== btn) {
                otherBtn.classList.add('disabled');
            }
        });

        try {
            const r = await fetch(`/api/test/${stepKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params)
            });
            const j = await r.json();
            if (!r.ok) throw new Error(j.error || 'Unknown error');
            showStatusMessage(j.status || 'Done');
        } catch (e) {
            // Show custom popup for B.3 offline authorization warning
            if (stepKey === 'run_b2_autonomous_start_test' && e.message.includes('offline authorization')) {
                showB1Warning(e.message, btn);
            }
            showStatusMessage(`Failed: ${e.message}`, true);
        } finally {
            // Fetch test results to get the latest test status
            await fetchChargePoints();

            // Remove running state AFTER fetching results
            btn.classList.remove('btn-running', 'disabled');
            activeTestKey = null;  // Clear active test marker

            // Manually apply the result color from the fetched data
            const cpData = chargePointsData[Object.keys(chargePointsData)[0]];
            if (cpData && cpData.test_results) {
                const result = cpData.test_results[stepKey];
                btn.classList.remove('btn-success', 'btn-failure', 'btn-skipped', 'btn-partial', 'btn-not-supported');
                if (result === 'PASSED') {
                    btn.classList.add('btn-success');
                } else if (result === 'FAILED') {
                    btn.classList.add('btn-failure');
                } else if (result === 'SKIPPED') {
                    btn.classList.add('btn-skipped');
                } else if (result === 'PARTIAL') {
                    btn.classList.add('btn-partial');
                } else if (result === 'NOT_SUPPORTED') {
                    btn.classList.add('btn-not-supported');
                }
            }

            // Re-enable other buttons
            document.querySelectorAll('.test-category .button-group button').forEach(otherBtn => {
                if (otherBtn !== btn) {
                    otherBtn.classList.remove('disabled');
                }
            });

            // Show verification results popup for C.1 and C.2 tests if they passed
            console.log(`üîç DEBUG: Checking if test requires verification. stepKey=${stepKey}`);
            if ((stepKey === 'run_c1_set_charging_profile_test' || stepKey === 'run_c2_tx_default_profile_test')) {
                console.log(`‚úÖ DEBUG: Test ${stepKey} requires verification`);
                const cpData = chargePointsData[Object.keys(chargePointsData)[0]];
                console.log(`üîç DEBUG: cpData =`, cpData);
                if (cpData && cpData.test_results) {
                    const result = cpData.test_results[stepKey];
                    console.log(`üîç DEBUG: Test result for ${stepKey} = ${result}`);
                    // Only show verification if test passed
                    if (result === 'PASSED') {
                        console.log(`‚úÖ DEBUG: Test passed, fetching verification results...`);
                        try {
                            // Determine which test (C1 or C2)
                            const testParam = stepKey === 'run_c1_set_charging_profile_test' ? 'C1' : 'C2';
                            console.log(`Fetching verification results for test: ${testParam}`);

                            const verifyResponse = await fetch(`/api/verification_results?test=${testParam}`);
                            if (verifyResponse.ok) {
                                const verifyData = await verifyResponse.json();
                                console.log('Verification data received:', verifyData);

                                // Defensive checks
                                if (verifyData && verifyData.results) {
                                    if (Array.isArray(verifyData.results) && verifyData.results.length > 0) {
                                        console.log(`‚úÖ DEBUG: Calling showVerificationResults with:`, verifyData.test, verifyData.results);
                                        showVerificationResults(verifyData.test, verifyData.results);
                                        console.log(`‚úÖ DEBUG: showVerificationResults called successfully`);
                                    } else {
                                        console.warn('‚ö†Ô∏è DEBUG: Verification results array is empty:', verifyData.results);
                                    }
                                } else {
                                    console.warn('‚ö†Ô∏è DEBUG: Verification data missing results field:', verifyData);
                                }
                            } else {
                                const errorText = await verifyResponse.text();
                                console.error('Failed to fetch verification results:', errorText);
                            }
                        } catch (verifyError) {
                            console.error('Exception fetching verification results:', verifyError);
                        }
                    }
                }
            }
        }
    }

    async function fetchAndRenderTestSteps() {
        const testDefinitions = {
            'run_a1_initial_registration': { name: 'A.1: Initial Registration', category: 'category-a-buttons' },
            'run_a2_get_configuration_test': { name: 'A.2: Get All Configuration', category: 'category-a-buttons' },
            'run_a3_change_configuration_test': { name: 'A.3: Get OCPP Standard Keys', category: 'category-a-buttons' },
            'run_a4_check_initial_state': { name: 'A.4: Check Initial State', category: 'category-a-buttons' },
            'run_a5_trigger_all_messages_test': { name: 'A.5: Trigger All Messages', category: 'category-a-buttons' },
            'run_a6_status_and_meter_value_acquisition': { name: 'A.6: Meter Values', category: 'category-a-buttons' },
            'run_b1_reset_transaction_management': { name: 'B.1: Reset Transaction Management', category: 'category-b-buttons' },
            'run_b2_autonomous_start_test': { name: 'B.2: Autonomous Start', category: 'category-b-buttons' },
            'run_b3_tap_to_charge_test': { name: 'B.3: RFID Tap-to-Charge', category: 'category-b-buttons' },
            'run_b4_anonymous_remote_start_test': { name: 'B.4: Anonymous Remote Start', category: 'category-b-buttons' },
            'run_b5_plug_and_charge_test': { name: 'B.5: Plug-and-Charge', category: 'category-b-buttons' },
            'run_b6_clear_rfid_cache': { name: 'B.6: Clear RFID Cache', category: 'category-b-buttons' },
            'run_b7_send_rfid_list': { name: 'B.7: Send RFID List', category: 'category-b-buttons' },
            'run_b8_get_rfid_list_version': { name: 'B.8: Get RFID List Version', category: 'category-b-buttons' },
            'run_x1_reboot_wallbox': { name: 'X.1: Reboot Wallbox', category: 'category-x-buttons' },
            'run_x2_dump_all_configuration': { name: 'X.2: Dump All Configuration', category: 'category-x-buttons' },
            'run_c1_set_charging_profile_test': { name: 'C.1: SetChargingProfile', category: 'category-c-buttons' },
            'run_c2_tx_default_profile_test': { name: 'C.2: TxDefaultProfile', category: 'category-c-buttons' },
            'run_c3_get_composite_schedule_test': { name: 'C.3: GetCompositeSchedule', category: 'category-c-buttons' },
            'run_c4_clear_charging_profile_test': { name: 'C.4: ClearChargingProfile', category: 'category-c-buttons' }
        };

        try {
            const r = await fetch('/api/test_steps');
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const steps = await r.json();

            document.querySelectorAll('.test-category .button-group').forEach(c => c.innerHTML = '');
            const ordered = Object.keys(testDefinitions).filter(k => steps.includes(k));

            for (const key of ordered) {
                const def = testDefinitions[key];
                const container = document.getElementById(def.category);
                const btn = document.createElement('button');
                btn.textContent = def.name;
                btn.dataset.stepKey = key;

                if (key === 'run_c1_set_charging_profile_test' || key === 'run_c2_tx_default_profile_test') {
                    btn.onclick = () => {
                        openChargingProfileModal(key);
                    };
                } else if (key === 'run_c3_get_composite_schedule_test') {
                    btn.onclick = async () => {
                        const r = await fetch('/api/discovered_charge_points');
                        const data = await r.json();
                        if (data.active_charge_point_id) {
                            runTestWithParams(key, {});
                        } else {
                            showStatusMessage('No active charge point selected.', true);
                        }
                    };
                } else if (key === 'run_b2_rfid_authorization_test') {
                    btn.onclick = () => {
                        openRfidModal();
                    };
                } else if (key === 'run_b3_tap_to_charge_test') {
                    btn.onclick = () => {
                        openTapToChargeModal();
                    };
                } else if (key === 'run_b4_anonymous_remote_start_test') {
                    btn.onclick = () => {
                        openRemoteStartModal();
                    };
                } else {
                    btn.onclick = async () => {
                        const r = await fetch('/api/discovered_charge_points');
                        const responseData = await r.json();
                        const backendActiveCpId = responseData.active_charge_point_id;

                        if (!backendActiveCpId) {
                            showStatusMessage("Please connect a wallbox first. No active wallbox detected.", true);
                            return;
                        }

                        // Remove any previous result colors and show running state
                        btn.classList.remove('btn-success', 'btn-failure', 'btn-skipped', 'btn-partial', 'btn-not-supported');
                        btn.classList.add('btn-running', 'disabled');
                        activeTestKey = key;  // Mark this test as active

                        // Disable other buttons during test
                        document.querySelectorAll('.test-category .button-group button').forEach(otherBtn => {
                            if (otherBtn !== btn) {
                                otherBtn.classList.add('disabled');
                            }
                        });

                        try {
                            const r = await fetch(`/api/test/${key}`, { method: 'POST' });
                            const j = await r.json();
                            if (!r.ok) throw new Error(j.error || 'Unknown error');
                            showStatusMessage(j.status || 'Done');
                        } catch (e) {
                            // Show custom popup for B.3 offline authorization warning
                            if (key === 'run_b2_autonomous_start_test' && e.message.includes('offline authorization')) {
                                showB1Warning(e.message, btn);
                            }
                            showStatusMessage(`Failed: ${e.message}`, true);
                        } finally {
                            // Fetch test results to get the latest test status
                            await fetchChargePoints();

                            // Remove running state AFTER fetching results
                            btn.classList.remove('btn-running', 'disabled');
                            activeTestKey = null;  // Clear active test marker

                            // Manually apply the result color from the fetched data
                            const cpData = chargePointsData[Object.keys(chargePointsData)[0]];
                            if (cpData && cpData.test_results) {
                                const result = cpData.test_results[key];
                                btn.classList.remove('btn-success', 'btn-failure', 'btn-skipped', 'btn-partial', 'btn-not-supported');
                                if (result === 'PASSED') {
                                    btn.classList.add('btn-success');
                                } else if (result === 'FAILED') {
                                    btn.classList.add('btn-failure');
                                } else if (result === 'SKIPPED') {
                                    btn.classList.add('btn-skipped');
                                } else if (result === 'PARTIAL') {
                                    btn.classList.add('btn-partial');
                                } else if (result === 'NOT_SUPPORTED') {
                                    btn.classList.add('btn-not-supported');
                                }
                            }

                            // Re-enable other buttons
                            document.querySelectorAll('.test-category .button-group button').forEach(otherBtn => {
                                if (otherBtn !== btn) {
                                    otherBtn.classList.remove('disabled');
                                }
                            });
                        }
                    };
                }
                container.appendChild(btn);
            }

            // Add "B All Tests" button to B section
            const categoryBContainer = document.getElementById('category-b-buttons');
            if (categoryBContainer) {
                const allTestsBtn = document.createElement('button');
                allTestsBtn.textContent = 'B All Tests (B.2-B.5)';
                allTestsBtn.style.backgroundColor = '#17a2b8';
                allTestsBtn.style.color = '#fff';
                allTestsBtn.style.fontWeight = 'bold';
                allTestsBtn.dataset.stepKey = 'b_all_tests';
                allTestsBtn.onclick = async () => {
                    const r = await fetch('/api/discovered_charge_points');
                    const responseData = await r.json();
                    const backendActiveCpId = responseData.active_charge_point_id;

                    if (!backendActiveCpId) {
                        showStatusMessage("Please connect a wallbox first. No active wallbox detected.", true);
                        return;
                    }

                    // Show running state
                    allTestsBtn.classList.remove('btn-success', 'btn-failure');
                    allTestsBtn.classList.add('btn-running', 'disabled');

                    // Disable other buttons during test
                    document.querySelectorAll('.test-category .button-group button').forEach(otherBtn => {
                        if (otherBtn !== allTestsBtn) {
                            otherBtn.classList.add('disabled');
                        }
                    });

                    const logFiles = [];

                    try {
                        // Run B.2
                        showStatusMessage('Running B.2: Autonomous Start...');
                        const b2Response = await fetch('/api/test/run_b2_autonomous_start_test', { method: 'POST' });
                        const b2Result = await b2Response.json();
                        if (b2Result.log_file) logFiles.push(b2Result.log_file);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        // Run B.3 with modal
                        showStatusMessage('Running B.3: Tap to Charge... (RFID modal will appear)');
                        await openTapToChargeModal();
                        // Get the most recent B.3 log file after modal closes
                        const b3LogResponse = await fetch('/api/test/get_latest_log?test_name=run_b3_tap_to_charge_test');
                        const b3LogResult = await b3LogResponse.json();
                        if (b3LogResult.log_file) logFiles.push(b3LogResult.log_file);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        // Run B.4
                        showStatusMessage('Running B.4: Anonymous Remote Start...');
                        const b4Response = await fetch('/api/test/run_b4_anonymous_remote_start_test', { method: 'POST' });
                        const b4Result = await b4Response.json();
                        if (b4Result.log_file) logFiles.push(b4Result.log_file);
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        // Run B.5
                        showStatusMessage('Running B.5: Plug and Charge...');
                        const b5Response = await fetch('/api/test/run_b5_plug_and_charge_test', { method: 'POST' });
                        const b5Result = await b5Response.json();
                        if (b5Result.log_file) logFiles.push(b5Result.log_file);
                        await new Promise(resolve => setTimeout(resolve, 1000));

                        // Combine log files
                        showStatusMessage('Combining log files...');
                        const combineResponse = await fetch('/api/test/combine_logs', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                log_files: logFiles,
                                test_name: 'b_all_tests'
                            })
                        });
                        const combineResult = await combineResponse.json();

                        // Fetch updated results
                        await fetchChargePoints();

                        // Get test results from charge point data
                        const cpResponse = await fetch('/api/charge_points');
                        const cpData = await cpResponse.json();
                        const activeCP = cpData.charge_points[backendActiveCpId];
                        const testResults = activeCP?.test_results || {};

                        const b2TestResult = testResults['run_b2_autonomous_start_test'] || 'NOT RUN';
                        const b3TestResult = testResults['run_b3_tap_to_charge_test'] || 'NOT RUN';
                        const b4TestResult = testResults['run_b4_anonymous_remote_start_test'] || 'NOT RUN';
                        const b5TestResult = testResults['run_b5_plug_and_charge_test'] || 'NOT RUN';

                        showStatusMessage(`B All Tests completed! Log saved to: ${combineResult.combined_log_file}`);

                        let message = `B All Tests Completed!\n\n`;
                        message += `Results:\n`;
                        message += `  B.2 Autonomous Start: ${b2TestResult}\n`;
                        message += `  B.3 Tap to Charge: ${b3TestResult}\n`;
                        message += `  B.4 Anonymous Remote Start: ${b4TestResult}\n`;
                        message += `  B.5 Plug and Charge: ${b5TestResult}\n\n`;
                        message += `Total: 4 tests completed\n\n`;
                        message += `Combined log file: ${combineResult.combined_log_file}`;

                        alert(message);

                        // Update button color based on results
                        const allPassed = b2TestResult === 'PASSED' && b3TestResult === 'PASSED' &&
                                        b4TestResult === 'PASSED' && b5TestResult === 'PASSED';
                        allTestsBtn.classList.add(allPassed ? 'btn-success' : 'btn-failure');

                    } catch (e) {
                        showStatusMessage(`Failed: ${e.message}`, true);
                        allTestsBtn.classList.add('btn-failure');
                    } finally {
                        // Remove running state
                        allTestsBtn.classList.remove('btn-running', 'disabled');

                        // Re-enable other buttons
                        document.querySelectorAll('.test-category .button-group button').forEach(otherBtn => {
                            if (otherBtn !== allTestsBtn) {
                                otherBtn.classList.remove('disabled');
                            }
                        });
                    }
                };
                categoryBContainer.appendChild(allTestsBtn);
            }

            // Add "C.1 and C.2 Tests" button to C section
            const categoryCContainer = document.getElementById('category-c-buttons');
            if (categoryCContainer) {
                const allTestsBtn = document.createElement('button');
                allTestsBtn.textContent = 'C.1 and C.2 Tests';
                allTestsBtn.style.backgroundColor = '#28a745';
                allTestsBtn.style.color = '#fff';
                allTestsBtn.style.fontWeight = 'bold';
                allTestsBtn.dataset.stepKey = 'c_all_tests';
                allTestsBtn.onclick = async () => {
                    const r = await fetch('/api/discovered_charge_points');
                    const responseData = await r.json();
                    const backendActiveCpId = responseData.active_charge_point_id;

                    if (!backendActiveCpId) {
                        showStatusMessage("Please connect a wallbox first. No active wallbox detected.", true);
                        return;
                    }

                    // Show running state
                    allTestsBtn.classList.remove('btn-success', 'btn-failure');
                    allTestsBtn.classList.add('btn-running', 'disabled');

                    // Disable other buttons during test
                    document.querySelectorAll('.test-category .button-group button').forEach(otherBtn => {
                        if (otherBtn !== allTestsBtn) {
                            otherBtn.classList.add('disabled');
                        }
                    });

                    try {
                        const response = await fetch('/api/test/c_all_tests', { method: 'POST' });
                        const result = await response.json();

                        if (!response.ok) throw new Error(result.error || 'Unknown error');

                        // Show status message with log file location
                        if (result.log_file) {
                            showStatusMessage(`C.1 and C.2 Tests completed! Log saved to: ${result.log_file}`);

                            // Show detailed results popup
                            const c1Result = result.test_results.c1 || 'NOT RUN';
                            const c2Result = result.test_results.c2 || 'NOT RUN';

                            let message = `C.1 and C.2 Tests Completed!\n\n`;
                            message += `Tested all charging rates: disable (0A), low (6A), medium (10A), high (16A)\n\n`;
                            message += `Results:\n`;
                            message += `  C.1 SetChargingProfile (4 iterations): ${c1Result}\n`;
                            message += `  C.2 TxDefaultProfile (4 iterations): ${c2Result}\n\n`;
                            message += `Total: 8 test runs completed\n\n`;
                            message += `Log file: ${result.log_file}`;

                            alert(message);

                            // Update button color based on results
                            const allPassed = c1Result === 'PASSED' && c2Result === 'PASSED';
                            allTestsBtn.classList.add(allPassed ? 'btn-success' : 'btn-failure');
                        } else {
                            showStatusMessage(result.status || 'Tests completed!');
                        }
                    } catch (e) {
                        showStatusMessage(`Failed: ${e.message}`, true);
                        allTestsBtn.classList.add('btn-failure');
                    } finally {
                        // Fetch test results to update UI
                        await fetchChargePoints();

                        // Remove running state
                        allTestsBtn.classList.remove('btn-running', 'disabled');

                        // Re-enable other buttons
                        document.querySelectorAll('.test-category .button-group button').forEach(otherBtn => {
                            if (otherBtn !== allTestsBtn) {
                                otherBtn.classList.remove('disabled');
                            }
                        });
                    }
                };
                categoryCContainer.appendChild(allTestsBtn);
            }

            // Add "Clear Test Results" button after X.2 in the System Control section
            const categoryXContainer = document.getElementById('category-x-buttons');
            if (categoryXContainer) {
                const clearBtn = document.createElement('button');
                clearBtn.textContent = 'Clear Test Results';
                clearBtn.style.backgroundColor = '#ffc107';
                clearBtn.style.color = '#000';
                clearBtn.onclick = clearTestResults;
                categoryXContainer.appendChild(clearBtn);
            }
        } catch (e) {
            console.error("Failed to load test steps", e);
        }
    }

    async function fetchServerSettings() {
        try {
            const r = await fetch('/api/settings');
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const settings = await r.json();

            serverSettings = settings;
            useSimulator = settings.use_simulator;
            const currentModeEl = document.getElementById('current-mode');

            if (settings.hasOwnProperty('use_simulator')) {
                if (useSimulator) {
                    currentModeEl.textContent = 'EV Simulator';
                    currentModeEl.style.color = '#007bff';
                    document.getElementById('ev-simulator-heading').style.display = 'block';
                    document.getElementById('ev-info').style.display = 'flex';
                    setEvStateButtonsEnabled(true);
                } else {
                    currentModeEl.textContent = 'Live EV';
                    currentModeEl.style.color = '#28a745';
                    document.getElementById('ev-simulator-heading').style.display = 'none';
                    document.getElementById('ev-info').style.display = 'none';
                    setEvStateButtonsEnabled(false);
                }
            }

        } catch (e) {
            console.error('Failed to fetch server settings:', e);
            const currentModeEl = document.getElementById('current-mode');
            currentModeEl.textContent = 'Status Unknown';
            currentModeEl.style.color = '#6c757d';
        }
    }

    function setEvStateButtonsEnabled(enabled) {
        document.querySelectorAll('#ev-info .button-group button').forEach(btn => {
            btn.disabled = !enabled;
            if (!enabled) {
                btn.classList.remove('active-state');
            }
        });
    }

    function updateEvStatusUI(status) {
        evStateEl.textContent = status.ev_state ?? 'N/A';
        evWallboxCurrentEl.textContent = status.wallbox_advertised_max_current_amps !== undefined ? `${status.wallbox_advertised_max_current_amps} A` : 'N/A';
        evVoltageEl.textContent = status.cp_voltage_v !== undefined ? `${status.cp_voltage_v.toFixed(2)} V` : 'N/A';
        evDutyCycleEl.textContent = status.cp_duty_cycle !== undefined ? `${(status.cp_duty_cycle * 100).toFixed(1)} %` : 'N/A';
        evPpVoltageEl.textContent = status.pp_voltage_v !== undefined ? `${status.pp_voltage_v.toFixed(2)} V` : 'N/A';

        let errorText = 'N/A';
        if (status.error_active) {
            errorText = `Active (${status.error_type || 'Unknown'})`;
        } else if (status.hasOwnProperty('error_active')) {
            errorText = 'Inactive';
        }
        evErrorEl.textContent = errorText;

        document.querySelectorAll('#ev-info .button-group button').forEach(btn => {
            btn.classList.remove('active-state');
        });

        if (status.ev_state) {
            const activeBtn = document.getElementById(`btn-state-${status.ev_state.toLowerCase()}`);
            if (activeBtn) {
                activeBtn.classList.add('active-state');
            }
        }
    }

    async function refreshEvStatus() {
        try {
            const r = await fetch('/api/ev_status');
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const s = await r.json();
            updateEvStatusUI(s);
        } catch {
            updateEvStatusUI({});
        }
    }

    function connectEvStatusSocket() {
        const proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${proto}//${window.location.hostname}:${WS_PORT}/ev-status`;
        const ws = new WebSocket(wsUrl);

        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                if (message.type === 'ev_status' && message.data) {
                    updateEvStatusUI(message.data);
                }
            } catch (e) {
                console.error("Failed to parse EV status WebSocket message", e);
            }
        };

        ws.onclose = function() {
            setTimeout(connectEvStatusSocket, 3000);
        };
    }

    function connectLogSocket() {
        const proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${proto}//${window.location.hostname}:${WS_PORT}/logs`;
        const ws = new WebSocket(wsUrl);

        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const logLine = document.createElement('div');
                logLine.className = `log-line ${message.levelname.toLowerCase()}`;
                logLine.textContent = message.message;
                logOutputEl.appendChild(logLine);
                logOutputEl.scrollTop = logOutputEl.scrollHeight;
            } catch (e) {
                console.error("Failed to parse log WebSocket message", e);
            }
        };

        ws.onclose = function() {
            setTimeout(connectLogSocket, 3000);
        };
    }

    async function setEvState(state) {
        if (!useSimulator) {
            showStatusMessage("Cannot set EV state: Simulator is disabled.", true);
            return;
        }

        try {
            const r = await fetch('/api/set_ev_state', {
                method: 'POST',
                headers: { 'Content-Type':'application/json' },
                body: JSON.stringify({ state })
            });
            const j = await r.json();
            if (!r.ok) throw new Error(j.error || 'Unknown error');
            showStatusMessage(j.message || 'OK');
            if (j.newState) {
                updateEvStatusUI(j.newState);
            }
        } catch (e) {
            showStatusMessage(e.message, true);
        }
    }

    async function setActiveChargePoint(cpId) {
        document.querySelectorAll('.test-category .button-group button').forEach(btn => {
            btn.classList.add('disabled');
        });

        try {
            const r = await fetch('/api/set_active_charge_point', {
                method: 'POST',
                headers: { 'Content-Type':'application/json' },
                body: JSON.stringify({ charge_point_id: cpId })
            });
            const j = await r.json();
            if (!r.ok) throw new Error(j.error || 'Request failed');
            showStatusMessage(j.message || 'Active charge point set.');
        } catch (e) {
            showStatusMessage(`Failed to set active charge point: ${e.message}`, true);
        } finally {
            document.querySelectorAll('.test-category .button-group button').forEach(btn => {
                btn.classList.remove('disabled');
            });
        }
    }

    shutdownServerButton.onclick = async () => {
        if (confirm("Are you sure you want to shut down the server?")) {
            try {
                const r = await fetch('/api/shutdown', { method: 'POST' });
                const j = await r.json();
                if (!r.ok) throw new Error(j.error || 'Unknown error');
                showStatusMessage(j.status || 'Server shutdown initiated.');
                document.querySelectorAll('button').forEach(btn => btn.disabled = true);
            } catch (e) {
                showStatusMessage(`Failed to shut down server: ${e.message}`, true);
            }
        }
    };

    async function clearTestResults() {
        if (confirm("Are you sure you want to clear all test results? This will remove all green/red colors from test buttons.")) {
            try {
                const r = await fetch('/api/clear_test_results', { method: 'POST' });
                const j = await r.json();
                if (!r.ok) throw new Error(j.error || 'Unknown error');
                showStatusMessage(j.message || 'Test results cleared.');

                // Manually remove all color classes from all test buttons
                document.querySelectorAll('.test-category .button-group button').forEach(btn => {
                    btn.classList.remove('btn-success', 'btn-failure', 'btn-running', 'btn-skipped', 'btn-partial', 'btn-not-supported');
                });

                // Refresh the charge points to update button colors
                await fetchChargePoints();
            } catch (e) {
                showStatusMessage(`Failed to clear test results: ${e.message}`, true);
            }
        }
    }

    async function rebootWallbox() {
        // Check if a wallbox is connected first
        try {
            const r = await fetch('/api/discovered_charge_points');
            const responseData = await r.json();
            const backendActiveCpId = responseData.active_charge_point_id;

            if (!backendActiveCpId) {
                showStatusMessage("Please connect a wallbox first. No active wallbox detected.", true);
                return;
            }

            if (confirm("Are you sure you want to reboot the wallbox? This will perform a hard reset.")) {
                const rebootBtn = document.getElementById('reboot-wallbox-button');
                rebootBtn.disabled = true;

                try {
                    const r = await fetch('/api/test/run_x1_reboot_wallbox', { method: 'POST' });
                    const j = await r.json();
                    if (!r.ok) throw new Error(j.error || 'Unknown error');
                    showStatusMessage(j.status || 'Wallbox reboot initiated.');
                } catch (e) {
                    showStatusMessage(`Failed to reboot wallbox: ${e.message}`, true);
                } finally {
                    rebootBtn.disabled = false;
                }
            }
        } catch (e) {
            showStatusMessage(`Failed to check wallbox connection: ${e.message}`, true);
        }
    }

    function updateWallboxCapabilityStatus() {
        const meterValuesContent = document.getElementById('meter-values-content');

        // Define default labels and values
        let voltageText = 'üîå Voltage: N/A';
        let currentText = '‚ö° Current: N/A';
        let powerText = 'üîã Power: N/A';
        let energyText = 'üìä Energy: N/A';

        if (window.transactionsData) {
            let meterValuesFound = false;
            for (const [txId, txData] of Object.entries(window.transactionsData)) {
                if (txData.meter_values && txData.meter_values.length > 0) {
                    meterValuesFound = true;
                    const latestMeter = txData.meter_values[txData.meter_values.length - 1];

                    if (latestMeter && latestMeter.sampledValue) {
                        const voltage = [];
                        const current = [];
                        const power = [];
                        const energy = [];

                        for (const sample of latestMeter.sampledValue) {
                            const measurand = sample.measurand || 'Unknown';
                            const value = parseFloat(sample.value || '0');
                            const unit = sample.unit || '';
                            const phase = sample.phase || '';
                            const item = { measurand, value, unit, phase };

                            if (measurand.includes('Voltage')) voltage.push(item);
                            else if (measurand.includes('Current')) current.push(item);
                            else if (measurand.includes('Power')) power.push(item);
                            else if (measurand.includes('Energy')) energy.push(item);
                        }

                        if (voltage.length > 0) {
                            voltageText = 'üîå Voltage: ';
                            voltage.forEach((v, i) => {
                                if (i > 0) voltageText += ', ';
                                voltageText += `${v.phase || 'L' + (i+1)}: ${v.value}${v.unit}`;
                            });
                        }

                        if (current.length > 0) {
                            currentText = '‚ö° Current: ';
                            current.forEach((c, i) => {
                                if (i > 0) currentText += ', ';
                                currentText += `${c.phase || 'L' + (i+1)}: ${c.value}${c.unit}`;
                            });
                        }

                        if (power.length > 0) {
                            powerText = 'üîã Power: ';
                            power.forEach((p, i) => {
                                if (i > 0) powerText += ', ';
                                powerText += `${p.phase || 'L' + (i+1)}: ${p.value}${p.unit}`;
                            });
                        }

                        if (energy.length > 0) {
                            energyText = 'üìä Energy: ';
                            energy.forEach((e, i) => {
                                if (i > 0) energyText += ', ';
                                energyText += `${e.value}${e.unit}`;
                            });
                        }
                    }
                    break; // Only process the first transaction with meter values
                }
            }
        }

        // Render the content with persistent labels
        meterValuesContent.innerHTML = `
            <div style="margin-bottom: 10px; font-weight: bold;">Live Measurements</div>
            <div style="margin-bottom: 8px;">${voltageText}</div>
            <div style="margin-bottom: 8px;">${currentText}</div>
            <div style="margin-bottom: 8px;">${powerText}</div>
            <div style="margin-bottom: 8px;">${energyText}</div>
        `;
    }

    async function fetchDiscoveredWallboxes() {
        try {
            const response = await fetch('/api/discovered_charge_points');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();
            updateWallboxDiscoveryUI(data);
        } catch (e) {
            console.error('Failed to fetch discovered wallboxes:', e);
        }
    }

    function updateWallboxDiscoveryUI(data) {
        const container = document.getElementById('wallboxes-container');
        const activeWallboxName = document.getElementById('active-wallbox-name');

        // Update active wallbox name or show connection message
        if (data.active_charge_point_id) {
            activeWallboxName.textContent = data.active_charge_point_id;
            // Enable buttons when wallbox is connected
            document.querySelectorAll('.test-category .button-group button').forEach(btn => {
                btn.classList.remove('disabled');
            });
            document.querySelectorAll('.analysis-btn').forEach(btn => {
                btn.disabled = false;
            });
        } else {
            const hostname = window.location.hostname;
            const port = WS_PORT;
            activeWallboxName.textContent = `No wallboxes discovered yet. Connect a wallbox to ws://${hostname}:${port}/YourWallboxID`;
            // Disable buttons when no wallbox is connected
            document.querySelectorAll('.test-category .button-group button').forEach(btn => {
                btn.classList.add('disabled');
            });
            document.querySelectorAll('.analysis-btn').forEach(btn => {
                btn.disabled = true;
            });
        }

        const discovered = data.discovered_charge_points;

        if (Object.keys(discovered).length === 0) {
            container.innerHTML = '';
        } else {
            container.innerHTML = '';
            Object.entries(discovered).forEach(([cpId, info]) => {
                const isActive = cpId === data.active_charge_point_id;
                const isConnected = info.status === 'connected';

                const wallboxItem = document.createElement('div');
                wallboxItem.className = `wallbox-item ${isActive ? 'active' : ''} ${!isConnected ? 'disconnected' : ''}`;

                wallboxItem.innerHTML = `
                    <div class="wallbox-info">
                        <div class="wallbox-name">${cpId}</div>
                        <div class="wallbox-details">
                            IP: ${info.remote_address || 'N/A'} |
                            Connections: ${info.connection_count || 0} |
                            First seen: ${info.first_seen ? new Date(info.first_seen).toLocaleTimeString() : 'N/A'}
                        </div>
                    </div>
                    <div class="wallbox-actions">
                        <span class="wallbox-status ${isConnected ? 'connected' : 'disconnected'}">
                            ${isConnected ? 'Connected' : 'Disconnected'}
                        </span>
                        ${isConnected && !isActive ?
                            `<button class="select-btn" onclick="selectWallbox('${cpId}')">Select</button>` : ''}
                        ${isActive ? '<span style="color:#4caf50; font-weight:bold;">ACTIVE</span>' : ''}
                    </div>
                `;

                container.appendChild(wallboxItem);
            });
        }
    }

    async function selectWallbox(chargePointId) {
        try {
            const response = await fetch('/api/select_charge_point', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ charge_point_id: chargePointId })
            });

            if (!response.ok) {
                const error = await response.json();
                alert(`Error: ${error.error}`);
                return;
            }

            const result = await response.json();
            fetchDiscoveredWallboxes();
        } catch (e) {
            console.error('Failed to select wallbox:', e);
            alert('Failed to select wallbox');
        }
    }


    setInterval(() => {
        fetchChargePoints();
        fetchTransactions();
        updateWallboxCapabilityStatus();
    }, 3000);
    setInterval(fetchServerSettings, 3000);
    setInterval(fetchDiscoveredWallboxes, 2000);

    fetchServerSettings();
    fetchAndRenderTestSteps();
    fetchDiscoveredWallboxes();
    fetchTransactions();

    updateWallboxCapabilityStatus();
    refreshEvStatus();
    connectEvStatusSocket();
    connectLogSocket();

    fetchChargePoints();

    document.addEventListener('DOMContentLoaded', (event) => {
        // Initially disable all buttons until we know if a wallbox is connected
        document.querySelectorAll('.analysis-btn').forEach(btn => {
            btn.disabled = true;
        });
        document.querySelectorAll('.test-category .button-group button').forEach(btn => {
            btn.classList.add('disabled');
        });

        const modal = document.getElementById('chargingProfileModal');
        const closeButton = document.getElementById('modal-close-button');
        const form = document.getElementById('chargingProfileForm');

        closeButton.onclick = function() {
            modal.style.display = "none";
        }

        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }

        form.onsubmit = function(event) {
            event.preventDefault();
            const stepKey = document.getElementById('modal-step-key').value;
            const params = {
                stackLevel: parseInt(form.stackLevel.value),
                chargingProfilePurpose: form.chargingProfilePurpose.value,
                chargingProfileKind: form.chargingProfileKind.value,
                chargingRateUnit: form.chargingRateUnit.value,
                limit: parseFloat(form.limit.value),
                numberPhases: parseInt(form.numberPhases.value),
                duration: parseInt(form.duration.value)
            };
            runTestWithParams(stepKey, params);
            modal.style.display = "none";
        }

        // Composite Schedule Modal Setup
        const compositeModal = document.getElementById('compositeScheduleModal');
        const compositeCloseButton = document.getElementById('composite-modal-close-button');
        const compositeForm = document.getElementById('compositeScheduleForm');

        compositeCloseButton.onclick = function() {
            compositeModal.style.display = "none";
        }

        window.onclick = function(event) {
            if (event.target == compositeModal) {
                compositeModal.style.display = "none";
            }
        }

        compositeForm.onsubmit = function(event) {
            event.preventDefault();
            const params = {
                connectorId: parseInt(compositeForm.connectorId.value),
                duration: parseInt(compositeForm.duration.value),
                chargingRateUnit: compositeForm.chargingRateUnit.value || null
            };
            runTestWithParams('run_c3_get_composite_schedule_test', params);
            compositeModal.style.display = "none";
        }

        // B.1 Warning Popup - Add overlay click handler
        const b1Overlay = document.getElementById('b1WarningOverlay');
        if (b1Overlay) {
            b1Overlay.onclick = closeB1Warning;
        }
    });

    // RFID Modal Functions
    let rfidTestInterval = null;
    let rfidStatusInterval = null;
    let rfidTestTimeRemaining = 60;
    let cardsDetected = { card1: null, card2: null };
    let lastKnownCards = [];

    function openRfidModal() {
        // Check if wallbox is connected
        fetch('/api/discovered_charge_points')
            .then(r => r.json())
            .then(responseData => {
                if (!responseData.active_charge_point_id) {
                    showStatusMessage("Please connect a wallbox first. No active wallbox detected.", true);
                    return;
                }

                const modal = document.getElementById('rfidModal');

                // Reset modal state
                resetRfidModal();

                modal.style.display = 'block';

                // Start the test automatically
                startRfidTest();
            })
            .catch(e => {
                showStatusMessage(`Failed to check wallbox connection: ${e.message}`, true);
            });
    }

    function resetRfidModal() {
        rfidTestTimeRemaining = 60;
        cardsDetected = { card1: null, card2: null };
        lastKnownCards = [];

        document.getElementById('rfid-timer').textContent = '‚è≥ Test starting...';
        document.getElementById('card1-result').textContent = 'Waiting...';
        document.getElementById('card2-result').textContent = 'Waiting...';
        document.getElementById('card1-status').style.backgroundColor = '#e9ecef';
        document.getElementById('card2-status').style.backgroundColor = '#e9ecef';
        document.getElementById('rfid-log').innerHTML = '<div>üìù Starting RFID authorization test...</div>';

        if (rfidTestInterval) {
            clearInterval(rfidTestInterval);
            rfidTestInterval = null;
        }

        if (rfidStatusInterval) {
            clearInterval(rfidStatusInterval);
            rfidStatusInterval = null;
        }
    }

    async function startRfidTest() {
        // Start polling for RFID status updates
        startRfidStatusPolling();

        // Start the backend test (async)
        setTimeout(async () => {
            try {
                addRfidLog('üöÄ Starting RFID authorization test...');

                const response = await fetch('/api/test/run_b2_rfid_authorization_test', { method: 'POST' });
                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || 'Test failed');
                }

                addRfidLog('‚úÖ Test completed successfully');
                document.getElementById('rfid-timer').textContent = '‚úÖ Test completed';

            } catch (e) {
                addRfidLog(`‚ùå Test failed: ${e.message}`);
                document.getElementById('rfid-timer').textContent = '‚ùå Test failed';
            }
        }, 100);

        // Start countdown timer
        rfidTestInterval = setInterval(() => {
            rfidTestTimeRemaining--;
            document.getElementById('rfid-timer').textContent = `‚è≥ Time remaining: ${rfidTestTimeRemaining}s`;

            if (rfidTestTimeRemaining <= 0) {
                clearInterval(rfidTestInterval);
                document.getElementById('rfid-timer').textContent = '‚è∞ Test time expired';
                addRfidLog('‚è∞ 60 second test period completed');
            }
        }, 1000);
    }

    function startRfidStatusPolling() {
        rfidStatusInterval = setInterval(async () => {
            try {
                const response = await fetch('/api/rfid_status');
                const status = await response.json();

                if (response.ok && status.active) {
                    // Check for new cards
                    const currentCards = status.cards_presented || [];

                    for (let i = 0; i < currentCards.length; i++) {
                        const cardId = currentCards[i];

                        // If this is a new card we haven't seen
                        if (!lastKnownCards.includes(cardId)) {
                            const cardNumber = i + 1;
                            const cardStatus = i === 0 ? 'Accepted' : 'Invalid';

                            updateCardStatus(cardNumber, cardId, cardStatus);
                            lastKnownCards.push(cardId);
                        }
                    }
                } else if (!status.active) {
                    // Test is no longer active, stop polling
                    if (rfidStatusInterval) {
                        clearInterval(rfidStatusInterval);
                        rfidStatusInterval = null;
                    }
                }
            } catch (e) {
                console.error('Error polling RFID status:', e);
            }
        }, 1000); // Poll every second
    }

    function addRfidLog(message) {
        const logDiv = document.getElementById('rfid-log');
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.innerHTML = `${timestamp}: ${message}`;
        logDiv.appendChild(logEntry);
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    function updateCardStatus(cardNumber, idTag, status) {
        const cardId = cardNumber === 1 ? 'card1' : 'card2';
        const resultEl = document.getElementById(`${cardId}-result`);
        const statusEl = document.getElementById(`${cardId}-status`);

        cardsDetected[cardId] = { idTag, status };

        resultEl.textContent = `${idTag} ‚Üí ${status}`;

        if (status === 'Accepted') {
            statusEl.style.backgroundColor = '#d4edda';
            statusEl.style.color = '#155724';
        } else {
            statusEl.style.backgroundColor = '#f8d7da';
            statusEl.style.color = '#721c24';
        }

        addRfidLog(`üé´ Card ${cardNumber}: ${idTag} ‚Üí ${status}`);
    }

    // Close modal handlers
    document.getElementById('rfid-modal-close').onclick = function() {
        closeRfidModal();
    }

    document.getElementById('rfid-close-btn').onclick = function() {
        closeRfidModal();
    }

    function closeRfidModal() {
        const modal = document.getElementById('rfidModal');
        modal.style.display = 'none';

        if (rfidTestInterval) {
            clearInterval(rfidTestInterval);
            rfidTestInterval = null;
        }
    }

    // Close modal when clicking outside
    window.onclick = function(event) {
        const rfidModal = document.getElementById('rfidModal');
        const chargingModal = document.getElementById('chargingProfileModal');

        if (event.target == rfidModal) {
            closeRfidModal();
        } else if (event.target == chargingModal) {
            chargingModal.style.display = "none";
        }
    }

    // B.3 RFID Tap-to-Charge Modal Functions
    let tapToChargeInterval = null;
    let tapToChargeTestStartTime = null;
    let tapToChargeTestActive = false;
    let initialTransactionIds = new Set();
    let initialAcceptedRfid = null;
    let tapToChargeModalResolver = null;  // Store resolver for Promise

    async function openTapToChargeModal() {
        // Return a Promise that resolves when the modal closes
        return new Promise(async (resolve, reject) => {
            try {
                // Store the resolver so closeTapToChargeModal can call it
                tapToChargeModalResolver = resolve;

                // Check if wallbox is connected
                const r = await fetch('/api/discovered_charge_points');
                const responseData = await r.json();

                if (!responseData.active_charge_point_id) {
                    showStatusMessage("Please connect a wallbox first. No active wallbox detected.", true);
                    tapToChargeModalResolver = null;
                    reject(new Error("No active wallbox"));
                    return;
                }

                // Enable RFID test mode and clear accepted_rfid to detect ANY card tap
                try {
                    const rfidResponse = await fetch('/api/enable_rfid_test_mode', { method: 'POST' });
                    if (rfidResponse.ok) {
                        console.log('‚úÖ B.3: RFID test mode enabled - any card will be accepted');
                    }
                } catch (e) {
                    console.error('Failed to enable RFID test mode:', e);
                }

                const modal = document.getElementById('tapToChargeModal');

                // Reset modal state (wait for it to capture existing transactions)
                await resetTapToChargeModal();

                modal.style.display = 'block';

                // Start the test automatically
                startTapToChargeTest();
            } catch (e) {
                showStatusMessage(`Failed to check wallbox connection: ${e.message}`, true);
                tapToChargeModalResolver = null;
                reject(e);
            }
        });
    }

    async function resetTapToChargeModal() {
        tapToChargeTestStartTime = Date.now();
        tapToChargeTestActive = false;

        document.getElementById('tap-to-charge-timer').textContent = '‚è≥ Please present your RFID card to the wallbox';
        document.getElementById('tap-to-charge-countdown').textContent = 'Time remaining: 60s';

        if (tapToChargeInterval) {
            clearInterval(tapToChargeInterval);
            tapToChargeInterval = null;
        }

        // Capture existing transaction IDs and accepted RFID to ignore them
        initialTransactionIds = new Set();
        initialAcceptedRfid = null;

        try {
            // Get initial transactions
            const response = await fetch('/api/transactions');
            if (response.ok) {
                const data = await response.json();
                const transactions = data.transactions || {};
                for (const txId of Object.keys(transactions)) {
                    initialTransactionIds.add(txId);
                }
                console.log('Initial transaction IDs:', Array.from(initialTransactionIds));
            }

            // Get initial accepted RFID
            const cpResponse = await fetch('/api/charge_points');
            if (cpResponse.ok) {
                const cpData = await cpResponse.json();
                const chargePoints = cpData.charge_points || {};
                const activeCpId = cpData.active_charge_point_id;

                if (activeCpId && chargePoints[activeCpId]) {
                    initialAcceptedRfid = chargePoints[activeCpId].accepted_rfid || null;
                    console.log('Initial accepted RFID:', initialAcceptedRfid);
                }
            }
        } catch (e) {
            console.error('Error fetching initial state:', e);
        }
    }

    async function startTapToChargeTest() {
        tapToChargeTestActive = true;

        // Start the backend test (fire and forget)
        fetch('/api/test/run_b3_tap_to_charge_test', { method: 'POST' })
            .then(r => r.json())
            .then(result => {
                console.log('B.3 test started:', result);
            })
            .catch(e => {
                console.error('Failed to start B.3 test:', e);
            });

        // Start polling for transaction status
        startTapToChargeStatusPolling();
    }

    function startTapToChargeStatusPolling() {
        let rfidDetectedInBackend = false;

        tapToChargeInterval = setInterval(async () => {
            const elapsed = Math.floor((Date.now() - tapToChargeTestStartTime) / 1000);
            const remaining = Math.max(0, 60 - elapsed);

            // Update countdown
            document.getElementById('tap-to-charge-countdown').textContent = `Time remaining: ${remaining}s`;

            // Check timeout
            if (remaining <= 0 && !rfidDetectedInBackend) {
                clearInterval(tapToChargeInterval);
                tapToChargeInterval = null;
                document.getElementById('tap-to-charge-timer').textContent = '‚è∞ Timeout - No RFID detected';
                tapToChargeTestActive = false;
                return;
            }

            try {
                // Check for new transactions - this is the most reliable indicator
                const response = await fetch('/api/transactions');
                if (!response.ok) return;

                const data = await response.json();
                const transactions = data.transactions || {};

                console.log('Polling - Transactions:', Object.keys(transactions).length, 'Initial IDs:', Array.from(initialTransactionIds));

                // Look for a NEW transaction (not in initial set)
                for (const [txId, txData] of Object.entries(transactions)) {
                    const isNew = !initialTransactionIds.has(txId);
                    console.log('TX', txId, '- isNew:', isNew, 'status:', txData.status);

                    // Detect ANY new transaction (ongoing or not)
                    if (isNew && !rfidDetectedInBackend) {
                        console.log('‚úÖ New transaction detected:', txId, '- closing modal');

                        // Transaction detected - close modal immediately
                        rfidDetectedInBackend = true;

                        // Stop polling
                        clearInterval(tapToChargeInterval);
                        tapToChargeInterval = null;
                        tapToChargeTestActive = false;

                        // Close modal immediately
                        closeTapToChargeModal();
                        return;
                    }
                }

                // Also check if accepted_rfid changed (backup method)
                const cpResponse = await fetch('/api/charge_points');
                if (cpResponse.ok) {
                    const cpData = await cpResponse.json();
                    const chargePoints = cpData.charge_points || {};
                    const activeCpId = cpData.active_charge_point_id;

                    if (activeCpId && chargePoints[activeCpId]) {
                        const cp = chargePoints[activeCpId];
                        const currentAcceptedRfid = cp.accepted_rfid || null;

                        console.log('Polling RFID - Initial:', initialAcceptedRfid, 'Current:', currentAcceptedRfid);

                        // Check if accepted_rfid has CHANGED from initial value
                        if (currentAcceptedRfid && currentAcceptedRfid !== initialAcceptedRfid && !rfidDetectedInBackend) {
                            console.log('‚úÖ RFID changed:', currentAcceptedRfid, '- closing modal');

                            rfidDetectedInBackend = true;
                            clearInterval(tapToChargeInterval);
                            tapToChargeInterval = null;
                            tapToChargeTestActive = false;
                            closeTapToChargeModal();
                            return;
                        }
                    }
                }
            } catch (e) {
                console.error('Error polling:', e);
            }
        }, 500); // Poll every 500ms for faster response
    }

    // Close modal handlers
    document.getElementById('tap-to-charge-modal-close').onclick = function() {
        closeTapToChargeModal();
    }

    function closeTapToChargeModal() {
        const modal = document.getElementById('tapToChargeModal');
        modal.style.display = 'none';

        if (tapToChargeInterval) {
            clearInterval(tapToChargeInterval);
            tapToChargeInterval = null;
        }

        tapToChargeTestActive = false;

        // Disable RFID test mode when closing
        fetch('/api/disable_rfid_test_mode', { method: 'POST' })
            .then(() => console.log('üîí B.3: RFID test mode disabled'))
            .catch(e => console.error('Failed to disable RFID test mode:', e));

        // Resolve the Promise so B All Tests can continue
        if (tapToChargeModalResolver) {
            console.log('‚úÖ Resolving B.3 modal promise - test complete');
            tapToChargeModalResolver();
            tapToChargeModalResolver = null;
        }
    }

    // Close modal when clicking outside
    window.addEventListener('click', function(event) {
        const tapToChargeModal = document.getElementById('tapToChargeModal');
        if (event.target === tapToChargeModal) {
            closeTapToChargeModal();
        }
    });

    // B.4 Anonymous Remote Start Modal Functions
    function openRemoteStartModal() {
        fetch('/api/discovered_charge_points')
            .then(r => r.json())
            .then(responseData => {
                if (!responseData.active_charge_point_id) {
                    showStatusMessage("Please connect a wallbox first. No active wallbox detected.", true);
                    return;
                }

                const modal = document.getElementById('remoteStartModal');
                modal.style.display = 'block';
            })
            .catch(e => {
                showStatusMessage(`Failed to check wallbox connection: ${e.message}`, true);
            });
    }

    function closeRemoteStartModal() {
        const modal = document.getElementById('remoteStartModal');
        modal.style.display = 'none';
    }

    // Close modal handlers
    document.getElementById('remote-start-modal-close').onclick = function() {
        closeRemoteStartModal();
    }

    document.getElementById('remote-start-cancel-btn').onclick = function() {
        closeRemoteStartModal();
    }

    // Form submit handler - anonymous remote start (no ID tag)
    document.getElementById('remoteStartForm').onsubmit = function(event) {
        event.preventDefault();

        // For anonymous remote start, don't send any idTag parameter
        const params = {};  // Empty params = anonymous charging
        runTestWithParams('run_b4_anonymous_remote_start_test', params);
        closeRemoteStartModal();
    }

    // Close modal when clicking outside
    window.addEventListener('click', function(event) {
        const remoteStartModal = document.getElementById('remoteStartModal');
        if (event.target === remoteStartModal) {
            closeRemoteStartModal();
        }
    });

    // Verification Modal Event Listeners
    document.getElementById('verification-modal-close').onclick = function() {
        closeVerificationModal();
    }

    document.getElementById('verification-ok-btn').onclick = function() {
        closeVerificationModal();
    }

    // Close verification modal when clicking outside
    window.addEventListener('click', function(event) {
        const verificationModal = document.getElementById('verificationResultsModal');
        if (event.target === verificationModal) {
            closeVerificationModal();
        }
    });

</script>
</body>
</html>