<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>OCPP Server UI</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <style>
        /* (unchanged styles trimmed for brevity) */
        body { font-family: Arial, sans-serif; background:#f4f4f4; margin:0; padding:20px; }
        .container { max-width:1400px; margin:auto; background:#fff; padding:20px; border-radius:8px; box-shadow:0 0 10px rgba(0,0,0,.1); }
        h1,h2 { color:#333; border-bottom:2px solid #eee; padding-bottom:10px; }
        .status-box { display:flex; justify-content:space-between; margin-bottom:20px; }
        .status-item { flex:1; padding:15px; margin:0 10px; background:#e9ecef; border-radius:8px; text-align:center; }
        .status-item h3 { margin-top:0; font-size:1em; text-align:center; }
        #charging-status { font-weight:bold; }
        .config-section { background:#e3f2fd; border:1px solid #90caf9; border-radius:8px; padding:15px; margin-bottom:20px; }
        .config-item { display:flex; align-items:center; gap:10px; margin-bottom:10px; }
        .config-item label { font-weight:bold; }
        .config-item select { padding:5px; border-radius:4px; border:1px solid #ccc; }
        .config-values { margin-top:10px; }
        .config-values p { margin:5px 0; font-weight:bold; }
        .button-group button:disabled { background:#6c757d; cursor:not-allowed; opacity:0.6; }
        .control-panel-grid { display:grid; grid-template-columns:1fr 1fr 1fr; gap:20px; margin-top:10px; }

        /* Wallbox Discovery Section */
        .wallbox-discovery-section { background:#f0f8f0; border:1px solid #90c695; border-radius:8px; padding:15px; margin-bottom:20px; }

        /* Wallbox Capabilities Section */
        .wallbox-capabilities-section { background:#e8f4fd; border:1px solid #64b5f6; border-radius:8px; padding:20px; margin-bottom:20px; }
        .capability-info { margin-bottom:20px; }
        .capability-info h3 { color:#1565c0; margin-top:0; }
        .capability-info ul { margin:10px 0; padding-left:20px; }
        .capability-info li { margin-bottom:8px; line-height:1.4; }

        .capability-status { background:#fff; border:1px solid #bbdefb; border-radius:6px; padding:15px; margin-bottom:20px; }
        .capability-status h4 { color:#1976d2; margin-top:0; margin-bottom:15px; }
        .status-indicator { display:flex; align-items:center; gap:10px; margin-bottom:10px; }
        .status-dot { width:12px; height:12px; border-radius:50%; display:inline-block; }
        .status-dot.waiting { background:#ffc107; animation:pulse 2s infinite; }
        .status-dot.connected { background:#28a745; }
        .status-dot.active { background:#17a2b8; }
        .status-dot.error { background:#dc3545; }

        .capability-action { text-align:center; }
        .capability-action h4 { color:#1976d2; margin-bottom:10px; }
        .quick-action { margin-top:15px; }
        .analysis-btn { background:#1976d2; color:white; border:none; padding:12px 24px; border-radius:6px; cursor:pointer; font-size:14px; font-weight:bold; }
        .analysis-btn:hover { background:#1565c0; }
        .analysis-btn:active { transform:translateY(1px); }
        .discovery-controls { display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; flex-wrap:wrap; gap:10px; }
        .autodiscovery-toggle label { display:flex; align-items:center; gap:8px; font-weight:bold; color:#2e7d32; }
        .active-wallbox { color:#1976d2; font-size:14px; }
        #active-wallbox-name { color:#d84315; font-weight:bold; }

        .discovered-wallboxes-list h4 { margin:0 0 10px 0; color:#2e7d32; }
        #wallboxes-container { display:flex; flex-direction:column; gap:8px; }
        .no-wallboxes { color:#666; font-style:italic; padding:10px; text-align:center; background:#fafafa; border-radius:4px; }

        .wallbox-item { display:flex; justify-content:space-between; align-items:center; padding:10px; background:#fff; border:1px solid #c8e6c9; border-radius:6px; }
        .wallbox-item.active { border-color:#4caf50; background:#e8f5e8; box-shadow:0 2px 4px rgba(76,175,80,0.2); }
        .wallbox-item.disconnected { border-color:#ff9800; background:#fff3e0; opacity:0.7; }

        .wallbox-info { display:flex; flex-direction:column; }
        .wallbox-name { font-weight:bold; color:#2e7d32; }
        .wallbox-details { font-size:12px; color:#666; margin-top:2px; }
        .wallbox-status { font-size:11px; padding:2px 6px; border-radius:10px; }
        .wallbox-status.connected { background:#c8e6c9; color:#2e7d32; }
        .wallbox-status.disconnected { background:#ffccbc; color:#d84315; }

        .wallbox-actions { display:flex; gap:8px; }
        .wallbox-actions button { padding:4px 8px; font-size:11px; border:none; border-radius:4px; cursor:pointer; }
        .select-btn { background:#4caf50; color:white; }
        .select-btn:hover { background:#45a049; }
        .select-btn:disabled { background:#cccccc; cursor:not-allowed; }
        .test-category { background:#f8f9fa; border:1px solid #dee2e6; border-radius:8px; padding:15px; }
        .button-group { display:flex; flex-wrap:wrap; gap:10px; }
        .button-group button { padding:10px 15px; font-size:14px; border:none; border-radius:5px; color:#fff; background:#007bff; cursor:pointer; }
        .button-group button.btn-success { background-color: #28a745; }
        .button-group button.btn-failure { background-color: #dc3545; }
        .button-group button.active-state { background-color: #28a745; }
        .button-group button.disabled { background:#6c757d; cursor:not-allowed; }
        .log-container { height:400px; overflow-y:scroll; border:1px solid #ccc; padding:10px; background:#f8f9fa; border-radius:8px; margin-top:20px; font-family:'Courier New', Courier, monospace; font-size:14px; }
        .log-line { white-space:pre-wrap; word-wrap:break-word; margin-bottom:5px; }
        .log-line.info { color:#007bff; } .log-line.error { color:#dc3545; font-weight:bold; } .log-line.warning { color:#ffc107; } .log-line.debug { color:#6c757d; }
    .wallbox-button.selected {
            background-color: #0056b3; /* A darker blue to indicate selection */
            border: 1px solid #0056b3;
        }
            .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgb(0,0,0); /* Fallback color */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto; /* 15% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%; /* Could be more or less, depending on screen size */
            max-width: 500px;
            border-radius: 8px;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
</style>
</head>
<body>
<div class="container">
    <h1>OCPP Server Status</h1>

    <h2>Discovered Wallboxes</h2>
    <div class="wallbox-discovery-section">
        <div class="discovery-controls">
            <div class="autodiscovery-toggle">
                <label>
                    <input type="checkbox" id="autodiscovery-enabled" checked>
                    Auto-select first wallbox
                </label>
            </div>
            <div class="active-wallbox">
                <strong>Active Wallbox:</strong> <span id="active-wallbox-name">None selected</span>
            </div>
        </div>

        <div class="discovered-wallboxes-list">
            <h4>Discovered Wallboxes:</h4>
            <div id="wallboxes-container">
                <div class="no-wallboxes">No wallboxes discovered yet. Connect a wallbox to ws://192.168.0.150:8887/YourWallboxID</div>
            </div>
        </div>
    </div>

    <h2>Charger Information</h2>
    <div id="charger-info">
        <p><strong>Vendor:</strong> <span id="vendor">N/A</span></p>
        <p><strong>Model:</strong> <span id="model">N/A</span></p>
        <p><strong>First Contact:</strong> <span id="first-status-time">N/A</span></p>
        <p><strong>Server Boot Time:</strong> <span id="boot-time">N/A</span></p>
        <p><strong>Status:</strong> <span id="charging-status">N/A</span></p>
        <p><strong>Current Charging:</strong> <span id="current-charging">0 W / 0 A</span></p>
        <p><strong>Last Heartbeat:</strong> <span id="last-heartbeat">N/A</span></p>
    </div>

    <h2>Mode Selection</h2>
    <div class="status-item" style="text-align: left; flex: none; margin: 0 0 20px 0;">
        <span style="font-weight: bold; font-size: 1.1em; margin-right: 10px;">Current Mode:</span>
        <span id="current-mode" style="font-weight: bold; font-size: 1.1em;">{{ initial_mode }}</span>
        <span style="font-weight: bold; font-size: 1.1em; margin-left: 20px; margin-right: 10px;">Active Transaction ID:</span>
        <span id="active-transaction-id-display" style="font-weight: bold; font-size: 1.1em;">N/A</span>
        <button id="shutdown-server-button" class="button shutdown-button" style="margin-left: 20px; background-color: #dc3545;">Shutdown Server</button>
    </div>

    
    <h2 id="ev-simulator-heading">EV Simulator Status</h2>
    <div id="ev-info" style="display:none; gap:20px;">
        <div id="ev-status-details" style="flex:1;">
            <p><strong>EV State:</strong> <span id="ev-state">N/A</span></p>
            <p><strong>Wallbox Advertised Current:</strong> <span id="ev-wallbox-current">N/A</span></p>
            <p><strong>CP Voltage:</strong> <span id="ev-voltage">N/A</span></p>
            <p><strong>CP Duty Cycle:</strong> <span id="ev-duty-cycle">N/A</span></p>
            <p><strong>PP Voltage:</strong> <span id="ev-pp-voltage">N/A</span></p>
            <p><strong>Error Status:</strong> <span id="ev-error">N/A</span></p>
        </div>
        <div class="button-group" style="flex:2; align-self:center;">
            <button id="btn-state-a" onclick="setEvState('A')">Set State A (Disconnected)</button>
            <button id="btn-state-b" onclick="setEvState('B')">Set State B (Connected)</button>
            <button id="btn-state-c" onclick="setEvState('C')">Set State C (Charging)</button>
            <button id="btn-state-e" onclick="setEvState('E')">Set State E (Error)</button>
        </div>
    </div>

    <h2>Wallbox offers to EV</h2>
    <div class="wallbox-capabilities-section">
        <div class="capability-info">
            <h3>ðŸ“Š Live MeterValues Data</h3>
            <p>Current electrical measurements from OCPP MeterValues messages:</p>

            <div id="meter-values-display" style="display: flex; font-family: monospace; background: #fff; border: 1px solid #ddd; padding: 15px; border-radius: 6px; margin: 15px 0;">
                <div id="meter-values-content" style="flex: 1;">Waiting for MeterValues data...</div>
                <div id="composite-schedule-display" style="flex: 1; padding-left: 15px; border-left: 1px solid #ddd;"></div>
            </div>


            <div class="quick-action" style="text-align: center; margin-top: 15px;">
                <button onclick="runTest('run_b1_remote_start_transaction_test')" class="analysis-btn">
                    âš¡ Start B.1 Transaction
                </button>
            </div>
        </div>
    </div>

    <h2>Control Panel</h2>
    <div class="control-panel-grid">
        <div class="test-category">
            <h3>A. Core Communication & Status</h3>
            <div class="button-group" id="category-a-buttons">
                <button data-step-key="run_a1_change_configuration_test">A.1: ChangeConfiguration</button>
                <button data-step-key="run_a2_get_configuration_test">A.2: GetConfiguration</button>
            </div>
        </div>
        <div class="test-category">
            <h3>B. Authorization & Transaction Management</h3>
            <div class="button-group" id="category-b-buttons">
                <button data-step-key="run_b1_remote_start_transaction_test">B.1: RemoteStartTransaction</button>
                <button data-step-key="run_b2_remote_stop_transaction_test">B.2: RemoteStopTransaction</button>
            </div>
        </div>
        <div class="test-category">
            <h3>C. Smart Charging Profile</h3>
            <div class="button-group" id="category-c-buttons">
                <button data-step-key="run_c1_set_charging_profile_test">C.1: SetChargingProfile</button>
                <button data-step-key="run_c2_get_composite_schedule_test">C.2: GetCompositeSchedule</button>
                <button data-step-key="run_c3_clear_charging_profile_test">C.3: ClearChargingProfile</button>
                <button data-step-key="run_c4_tx_default_profile_test">C.4: TxDefaultProfile</button>
            </div>
        </div>
    </div>
    <div id="status-message" class="status-message" style="display:none;"></div>

    <h2>Logs</h2>
    <div class="log-container" id="log-output"></div>
</div>

<div id="chargingProfileModal" class="modal">
  <!-- Modal content -->
  <div class="modal-content">
    <span class="close" id="modal-close-button">&times;</span>
    <h3 id="modal-title">Set Charging Profile</h3>
    <form id="chargingProfileForm">
        <input type="hidden" id="modal-step-key" />
        <div class="form-group">
            <label for="stackLevel">Stack Level</label>
            <input type="number" id="stackLevel" name="stackLevel" value="0">
        </div>
        <div class="form-group">
            <label for="chargingProfilePurpose">Profile Purpose</label>
            <select id="chargingProfilePurpose" name="chargingProfilePurpose">
                <option value="ChargePointMaxProfile">ChargePointMaxProfile</option>
                <option value="TxDefaultProfile">TxDefaultProfile</option>
                <option value="TxProfile">TxProfile</option>
            </select>
        </div>
        <div class="form-group">
            <label for="chargingProfileKind">Profile Kind</label>
            <select id="chargingProfileKind" name="chargingProfileKind">
                <option value="Absolute">Absolute</option>
                <option value="Recurring">Recurring</option>
                <option value="Relative">Relative</option>
            </select>
        </div>
        <div class="form-group">
            <label for="limit">Limit (Amps or Watts)</label>
            <input type="number" id="limit" name="limit" value="0">
        </div>
        <div class="form-group">
            <label for="duration">Duration (seconds)</label>
            <input type="number" id="duration" name="duration" value="3600">
        </div>
        <button type="submit">Run Test</button>
    </form>
  </div>
</div>
<script>
    const chargingStatusEl = document.getElementById("charging-status");
    const currentChargingEl = document.getElementById("current-charging");
    const shutdownServerButton = document.getElementById("shutdown-server-button");
    const vendorEl = document.getElementById("vendor");
    const modelEl = document.getElementById("model");
    const firstStatusTimeEl = document.getElementById("first-status-time");
    const bootTimeEl = document.getElementById("boot-time");
    const lastHeartbeatEl = document.getElementById("last-heartbeat");
    const statusMessageEl = document.getElementById("status-message");
    const logOutputEl = document.getElementById("log-output");
    const activeTransactionIdDisplay = document.getElementById("active-transaction-id-display");

    const evStateEl = document.getElementById("ev-state");
    const evVoltageEl = document.getElementById("ev-voltage");
    const evErrorEl = document.getElementById("ev-error");
    const evWallboxCurrentEl = document.getElementById("ev-wallbox-current");
    const evDutyCycleEl = document.getElementById("ev-duty-cycle");
    const evPpVoltageEl = document.getElementById("ev-pp-voltage");

    const WS_PORT = {{ ocpp_port }};

    let chargePointsData = {};
    let transactionsData = {};
    let isConnected = false;
    let useSimulator = false;

    function showStatusMessage(message, isError = false) {
        statusMessageEl.textContent = message;
        statusMessageEl.className = `status-message ${isError ? 'error' : 'success'}`;
        statusMessageEl.style.display = 'block';
        setTimeout(() => statusMessageEl.style.display = 'none', 5000);
    }

    function updateChargePointDetails(cpId) {
        const cp = chargePointsData[cpId];
        if (cp) {
            vendorEl.textContent = cp.vendor || 'N/A';
            modelEl.textContent = cp.model || 'N/A';
            firstStatusTimeEl.textContent = cp.first_status_time ? new Date(cp.first_status_time).toLocaleString() : 'N/A';
            bootTimeEl.textContent = cp.boot_time ? new Date(cp.boot_time).toLocaleString() : 'N/A';
            chargingStatusEl.textContent = cp.status || 'N/A';
            const powerW = cp.current_power_w || 0;
            const currentA = cp.current_current_a || 0;
            currentChargingEl.textContent = `${powerW.toFixed(0)} W / ${currentA.toFixed(1)} A`;
            lastHeartbeatEl.textContent = cp.last_heartbeat ? new Date(cp.last_heartbeat).toLocaleString() : 'N/A';
            document.querySelectorAll('.test-category .button-group button').forEach(btn => {
                btn.classList.remove('disabled');
            });
            const testResults = cp.test_results || {};
            document.querySelectorAll('[data-step-key]').forEach(btn => {
                const stepKey = btn.dataset.stepKey;
                const result = testResults[stepKey];
                btn.classList.remove('btn-success', 'btn-failure');
                if (result === 'PASSED') {
                    btn.classList.add('btn-success');
                } else if (result === 'FAILED') {
                    btn.classList.add('btn-failure');
                }
            });

            const scheduleContainer = document.getElementById('composite-schedule-display');
            if (cp.composite_schedule && cp.composite_schedule.chargingSchedulePeriod) {
                let scheduleHtml = '<h4>Composite Schedule</h4>';
                scheduleHtml += `<ul>`;
                cp.composite_schedule.chargingSchedulePeriod.forEach((period, index) => {
                    scheduleHtml += `<li>Period ${index + 1}: Start ${period.startPeriod}s, Limit ${period.limit}${cp.composite_schedule.chargingRateUnit}, Phases ${period.numberPhases || 'N/A'}</li>`;
                });
                scheduleHtml += `</ul>`;
                scheduleContainer.innerHTML = scheduleHtml;
            } else {
                scheduleContainer.innerHTML = '';
            }

        } else {
            ['vendor', 'model', 'first-status-time', 'boot-time', 'charging-status', 'last-heartbeat'].forEach(id => document.getElementById(id).textContent = 'N/A');
            currentChargingEl.textContent = '0 W / 0.0 A';
            document.querySelectorAll('.test-category .button-group button').forEach(btn => {
                btn.classList.add('disabled');
                btn.classList.remove('btn-success', 'btn-failure');
            });
        }
    }

    async function fetchChargePoints() {
        try {
            const r = await fetch('/api/charge_points');
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const responseData = await r.json();
            chargePointsData = responseData.charge_points;
            const activeCpId = responseData.active_charge_point_id;
            const activeTxId = responseData.active_transaction_id;
            const ids = Object.keys(chargePointsData);
            if (ids.length > 0) {
                updateChargePointDetails(activeCpId);
                activeTransactionIdDisplay.textContent = activeTxId !== null ? activeTxId : 'N/A';
            }
        } catch (e) {
            console.error(e);
        }
    }

    async function fetchTransactions() {
        try {
            const r = await fetch('/api/transactions');
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const responseData = await r.json();
            transactionsData = responseData.transactions;
            window.transactionsData = transactionsData;
        } catch (e) {
            console.error('Error fetching transactions:', e);
        }
    }

    function openChargingProfileModal(stepKey) {
        const modal = document.getElementById('chargingProfileModal');
        const modalTitle = document.getElementById('modal-title');
        const stepKeyInput = document.getElementById('modal-step-key');
        const form = document.getElementById('chargingProfileForm');
        const purposeSelect = form.chargingProfilePurpose;

        stepKeyInput.value = stepKey;

        // Show all options first
        for (let i = 0; i < purposeSelect.options.length; i++) {
            purposeSelect.options[i].style.display = "";
        }

        // Set defaults based on the test case
        if (stepKey === 'run_c1_set_charging_profile_test') {
            modalTitle.textContent = 'C.1: SetChargingProfile';
            form.stackLevel.value = 0;
            form.chargingProfilePurpose.value = 'TxProfile';
            form.chargingProfileKind.value = 'Absolute';
            form.limit.value = 0; // 'disable' value
            form.duration.value = 3600;

            // Hide TxDefaultProfile for C.1
            for (let i = 0; i < purposeSelect.options.length; i++) {
                if (purposeSelect.options[i].value === 'TxDefaultProfile') {
                    purposeSelect.options[i].style.display = "none";
                }
            }

        } else if (stepKey === 'run_c4_tx_default_profile_test') {
            modalTitle.textContent = 'C.4: TxDefaultProfile';
            form.stackLevel.value = 0;
            form.chargingProfilePurpose.value = 'TxDefaultProfile';
            form.chargingProfileKind.value = 'Absolute';
            form.limit.value = 5000; // 'medium' value
            form.duration.value = 3600;
        }

        modal.style.display = 'block';
    }

    async function runTestWithParams(stepKey, params) {
        const btn = document.querySelector(`[data-step-key='${stepKey}']`);
        btn.classList.add('disabled');
        document.querySelectorAll('.test-category .button-group button').forEach(otherBtn => {
            if (otherBtn !== btn) {
                otherBtn.classList.add('disabled');
            }
        });

        try {
            const r = await fetch(`/api/test/${stepKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params)
            });
            const j = await r.json();
            if (!r.ok) throw new Error(j.error || 'Unknown error');
            showStatusMessage(j.status || 'Done');
        } catch (e) {
            showStatusMessage(`Failed: ${e.message}`, true);
        } finally {
            await fetchChargePoints();
            btn.classList.remove('disabled');
            document.querySelectorAll('.test-category .button-group button').forEach(otherBtn => {
                if (otherBtn !== btn) {
                    otherBtn.classList.remove('disabled');
                }
            });
        }
    }

    async function fetchAndRenderTestSteps() {
        const testDefinitions = {
            'run_a1_change_configuration_test': { name: 'A.1: ChangeConfiguration', category: 'category-a-buttons' },
            'run_a2_get_configuration_test': { name: 'A.2: GetConfiguration', category: 'category-a-buttons' },
            'run_b1_remote_start_transaction_test': { name: 'B.1: RemoteStartTransaction', category: 'category-b-buttons' },
            'run_b2_remote_stop_transaction_test': { name: 'B.2: RemoteStopTransaction', category: 'category-b-buttons' },
            'run_c1_set_charging_profile_test': { name: 'C.1: SetChargingProfile', category: 'category-c-buttons' },
            'run_c2_get_composite_schedule_test': { name: 'C.2: GetCompositeSchedule', category: 'category-c-buttons' },
            'run_c3_clear_charging_profile_test': { name: 'C.3: ClearChargingProfile', category: 'category-c-buttons' },
            'run_c4_tx_default_profile_test': { name: 'C.4: TxDefaultProfile', category: 'category-c-buttons' }
        };

        try {
            const r = await fetch('/api/test_steps');
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const steps = await r.json();

            document.querySelectorAll('.test-category .button-group').forEach(c => c.innerHTML = '');
            const ordered = Object.keys(testDefinitions).filter(k => steps.includes(k));

            for (const key of ordered) {
                const def = testDefinitions[key];
                const container = document.getElementById(def.category);
                const btn = document.createElement('button');
                btn.textContent = def.name;
                btn.dataset.stepKey = key;

                if (key === 'run_c1_set_charging_profile_test' || key === 'run_c4_tx_default_profile_test') {
                    btn.onclick = () => {
                        openChargingProfileModal(key);
                    };
                } else {
                    btn.onclick = async () => {
                        const r = await fetch('/api/discovered_charge_points');
                        const responseData = await r.json();
                        const backendActiveCpId = responseData.active_charge_point_id;

                        if (!backendActiveCpId) {
                            showStatusMessage("Please connect a wallbox first. No active wallbox detected.", true);
                            return;
                        }

                        btn.classList.add('disabled');
                        document.querySelectorAll('.test-category .button-group button').forEach(otherBtn => {
                            if (otherBtn !== btn) {
                                otherBtn.classList.add('disabled');
                            }
                        });

                        try {
                            const r = await fetch(`/api/test/${key}`, { method: 'POST' });
                            const j = await r.json();
                            if (!r.ok) throw new Error(j.error || 'Unknown error');
                            showStatusMessage(j.status || 'Done');
                        } catch (e) {
                            showStatusMessage(`Failed: ${e.message}`, true);
                        } finally {
                            await fetchChargePoints();
                            btn.classList.remove('disabled');
                            document.querySelectorAll('.test-category .button-group button').forEach(otherBtn => {
                                if (otherBtn !== btn) {
                                    otherBtn.classList.remove('disabled');
                                }
                            });
                        }
                    };
                }
                container.appendChild(btn);
            }
        } catch (e) {
            console.error("Failed to load test steps", e);
        }
    }

    async function fetchServerSettings() {
        try {
            const r = await fetch('/api/settings');
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const settings = await r.json();

            useSimulator = settings.use_simulator;
            const currentModeEl = document.getElementById('current-mode');

            if (settings.hasOwnProperty('use_simulator')) {
                if (useSimulator) {
                    currentModeEl.textContent = 'EV Simulator';
                    currentModeEl.style.color = '#007bff';
                    document.getElementById('ev-simulator-heading').style.display = 'block';
                    document.getElementById('ev-info').style.display = 'flex';
                    setEvStateButtonsEnabled(true);
                } else {
                    currentModeEl.textContent = 'Live EV';
                    currentModeEl.style.color = '#28a745';
                    document.getElementById('ev-simulator-heading').style.display = 'none';
                    document.getElementById('ev-info').style.display = 'none';
                    setEvStateButtonsEnabled(false);
                }
            }

        } catch (e) {
            console.error('Failed to fetch server settings:', e);
            const currentModeEl = document.getElementById('current-mode');
            currentModeEl.textContent = 'Status Unknown';
            currentModeEl.style.color = '#6c757d';
        }
    }

    function setEvStateButtonsEnabled(enabled) {
        document.querySelectorAll('#ev-info .button-group button').forEach(btn => {
            btn.disabled = !enabled;
            if (!enabled) {
                btn.classList.remove('active-state');
            }
        });
    }

    function updateEvStatusUI(status) {
        evStateEl.textContent = status.ev_state ?? 'N/A';
        evWallboxCurrentEl.textContent = status.wallbox_advertised_max_current_amps !== undefined ? `${status.wallbox_advertised_max_current_amps} A` : 'N/A';
        evVoltageEl.textContent = status.cp_voltage_v !== undefined ? `${status.cp_voltage_v.toFixed(2)} V` : 'N/A';
        evDutyCycleEl.textContent = status.cp_duty_cycle !== undefined ? `${(status.cp_duty_cycle * 100).toFixed(1)} %` : 'N/A';
        evPpVoltageEl.textContent = status.pp_voltage_v !== undefined ? `${status.pp_voltage_v.toFixed(2)} V` : 'N/A';

        let errorText = 'N/A';
        if (status.error_active) {
            errorText = `Active (${status.error_type || 'Unknown'})`;
        } else if (status.hasOwnProperty('error_active')) {
            errorText = 'Inactive';
        }
        evErrorEl.textContent = errorText;

        document.querySelectorAll('#ev-info .button-group button').forEach(btn => {
            btn.classList.remove('active-state');
        });

        if (status.ev_state) {
            const activeBtn = document.getElementById(`btn-state-${status.ev_state.toLowerCase()}`);
            if (activeBtn) {
                activeBtn.classList.add('active-state');
            }
        }
    }

    async function refreshEvStatus() {
        try {
            const r = await fetch('/api/ev_status');
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const s = await r.json();
            updateEvStatusUI(s);
        } catch {
            updateEvStatusUI({});
        }
    }

    function connectEvStatusSocket() {
        const proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${proto}//${window.location.hostname}:${WS_PORT}/ev-status`;
        const ws = new WebSocket(wsUrl);

        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                if (message.type === 'ev_status' && message.data) {
                    updateEvStatusUI(message.data);
                }
            } catch (e) {
                console.error("Failed to parse EV status WebSocket message", e);
            }
        };

        ws.onclose = function() {
            setTimeout(connectEvStatusSocket, 3000);
        };
    }

    function connectLogSocket() {
        const proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${proto}//${window.location.hostname}:${WS_PORT}/logs`;
        const ws = new WebSocket(wsUrl);

        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const logLine = document.createElement('div');
                logLine.className = `log-line ${message.levelname.toLowerCase()}`;
                logLine.textContent = message.message;
                logOutputEl.appendChild(logLine);
                logOutputEl.scrollTop = logOutputEl.scrollHeight;
            } catch (e) {
                console.error("Failed to parse log WebSocket message", e);
            }
        };

        ws.onclose = function() {
            setTimeout(connectLogSocket, 3000);
        };
    }

    async function setEvState(state) {
        if (!useSimulator) {
            showStatusMessage("Cannot set EV state: Simulator is disabled.", true);
            return;
        }

        try {
            const r = await fetch('/api/set_ev_state', {
                method: 'POST',
                headers: { 'Content-Type':'application/json' },
                body: JSON.stringify({ state })
            });
            const j = await r.json();
            if (!r.ok) throw new Error(j.error || 'Unknown error');
            showStatusMessage(j.message || 'OK');
            if (j.newState) {
                updateEvStatusUI(j.newState);
            }
        } catch (e) {
            showStatusMessage(e.message, true);
        }
    }

    async function setActiveChargePoint(cpId) {
        document.querySelectorAll('.test-category .button-group button').forEach(btn => {
            btn.classList.add('disabled');
        });

        try {
            const r = await fetch('/api/set_active_charge_point', {
                method: 'POST',
                headers: { 'Content-Type':'application/json' },
                body: JSON.stringify({ charge_point_id: cpId })
            });
            const j = await r.json();
            if (!r.ok) throw new Error(j.error || 'Request failed');
            showStatusMessage(j.message || 'Active charge point set.');
        } catch (e) {
            showStatusMessage(`Failed to set active charge point: ${e.message}`, true);
        } finally {
            document.querySelectorAll('.test-category .button-group button').forEach(btn => {
                btn.classList.remove('disabled');
            });
        }
    }

    shutdownServerButton.onclick = async () => {
        if (confirm("Are you sure you want to shut down the server?")) {
            try {
                const r = await fetch('/api/shutdown', { method: 'POST' });
                const j = await r.json();
                if (!r.ok) throw new Error(j.error || 'Unknown error');
                showStatusMessage(j.status || 'Server shutdown initiated.');
                document.querySelectorAll('button').forEach(btn => btn.disabled = true);
            } catch (e) {
                showStatusMessage(`Failed to shut down server: ${e.message}`, true);
            }
        }
    };

    function updateWallboxCapabilityStatus() {
        const meterValuesContent = document.getElementById('meter-values-content');

        if (!window.transactionsData) {
            meterValuesContent.textContent = 'Loading transaction data...';
            return;
        }

        let meterValuesFound = false;
        for (const [txId, txData] of Object.entries(window.transactionsData)) {
            if (txData.meter_values && txData.meter_values.length > 0) {
                meterValuesFound = true;
                const latestMeter = txData.meter_values[txData.meter_values.length - 1];
                meterValuesContent.innerHTML = '';

                const header = document.createElement('div');
                header.style.marginBottom = '10px';
                header.style.fontWeight = 'bold';
                header.textContent = `Transaction ${txId} (${txData.status || 'Unknown'}) - ${txData.meter_values.length} readings`;
                meterValuesContent.appendChild(header);

                if (latestMeter && latestMeter.sampledValue) {
                    const voltage = [];
                    const current = [];
                    const power = [];
                    const energy = [];

                    for (const sample of latestMeter.sampledValue) {
                        const measurand = sample.measurand || 'Unknown';
                        const value = parseFloat(sample.value || '0');
                        const unit = sample.unit || '';
                        const phase = sample.phase || '';
                        const item = { measurand, value, unit, phase };

                        if (measurand.includes('Voltage')) voltage.push(item);
                        else if (measurand.includes('Current')) current.push(item);
                        else if (measurand.includes('Power')) power.push(item);
                        else if (measurand.includes('Energy')) energy.push(item);
                    }

                    if (voltage.length > 0) {
                        const voltageDiv = document.createElement('div');
                        voltageDiv.style.marginBottom = '8px';
                        let voltageText = 'ðŸ”Œ Voltage: ';
                        voltage.forEach((v, i) => {
                            if (i > 0) voltageText += ', ';
                            voltageText += `${v.phase || 'L' + (i+1)}: ${v.value}${v.unit}`;
                        });
                        voltageDiv.textContent = voltageText;
                        meterValuesContent.appendChild(voltageDiv);
                    }

                    if (current.length > 0) {
                        const currentDiv = document.createElement('div');
                        currentDiv.style.marginBottom = '8px';
                        let currentText = 'âš¡ Current: ';
                        current.forEach((c, i) => {
                            if (i > 0) currentText += ', ';
                            currentText += `${c.phase || 'L' + (i+1)}: ${c.value}${c.unit}`;
                        });
                        currentDiv.textContent = currentText;
                        meterValuesContent.appendChild(currentDiv);
                    }

                    if (power.length > 0) {
                        const powerDiv = document.createElement('div');
                        powerDiv.style.marginBottom = '8px';
                        let powerText = 'ðŸ”‹ Power: ';
                        power.forEach((p, i) => {
                            if (i > 0) powerText += ', ';
                            powerText += `${p.phase || 'L' + (i+1)}: ${p.value}${p.unit}`;
                        });
                        powerDiv.textContent = powerText;
                        meterValuesContent.appendChild(powerDiv);
                    }

                    if (energy.length > 0) {
                        const energyDiv = document.createElement('div');
                        energyDiv.style.marginBottom = '8px';
                        let energyText = 'ðŸ“Š Energy: ';
                        energy.forEach((e, i) => {
                            if (i > 0) energyText += ', ';
                            energyText += `${e.value}${e.unit}`;
                        });
                        energyDiv.textContent = energyText;
                        meterValuesContent.appendChild(energyDiv);
                    }
                }
                break;
            }
        }

        if (!meterValuesFound) {
            meterValuesContent.textContent = 'No MeterValues data available. Start a charging transaction to see live measurements.';
        }
    }

    async function fetchDiscoveredWallboxes() {
        try {
            const response = await fetch('/api/discovered_charge_points');
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const data = await response.json();
            updateWallboxDiscoveryUI(data);
        } catch (e) {
            console.error('Failed to fetch discovered wallboxes:', e);
        }
    }

    function updateWallboxDiscoveryUI(data) {
        const container = document.getElementById('wallboxes-container');
        const activeWallboxName = document.getElementById('active-wallbox-name');
        const autodiscoveryCheckbox = document.getElementById('autodiscovery-enabled');

        autodiscoveryCheckbox.checked = data.autodiscovery_enabled;
        activeWallboxName.textContent = data.active_charge_point_id || 'None selected';

        const discovered = data.discovered_charge_points;

        if (Object.keys(discovered).length === 0) {
            container.innerHTML = '<div class="no-wallboxes">No wallboxes discovered yet. Connect a wallbox to ws://192.168.0.150:8887/YourWallboxID</div>';
        } else {
            container.innerHTML = '';
            Object.entries(discovered).forEach(([cpId, info]) => {
                const isActive = cpId === data.active_charge_point_id;
                const isConnected = info.status === 'connected';

                const wallboxItem = document.createElement('div');
                wallboxItem.className = `wallbox-item ${isActive ? 'active' : ''} ${!isConnected ? 'disconnected' : ''}`;

                wallboxItem.innerHTML = `
                    <div class="wallbox-info">
                        <div class="wallbox-name">${cpId}</div>
                        <div class="wallbox-details">
                            IP: ${info.remote_address || 'N/A'} |
                            Connections: ${info.connection_count || 0} |
                            First seen: ${info.first_seen ? new Date(info.first_seen).toLocaleTimeString() : 'N/A'}
                        </div>
                    </div>
                    <div class="wallbox-actions">
                        <span class="wallbox-status ${isConnected ? 'connected' : 'disconnected'}">
                            ${isConnected ? 'Connected' : 'Disconnected'}
                        </span>
                        ${isConnected && !isActive ?
                            `<button class="select-btn" onclick="selectWallbox('${cpId}')">Select</button>` : ''}
                        ${isActive ? '<span style="color:#4caf50; font-weight:bold;">ACTIVE</span>' : ''}
                    </div>
                `;

                container.appendChild(wallboxItem);
            });
        }
    }

    async function selectWallbox(chargePointId) {
        try {
            const response = await fetch('/api/select_charge_point', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ charge_point_id: chargePointId })
            });

            if (!response.ok) {
                const error = await response.json();
                alert(`Error: ${error.error}`);
                return;
            }

            const result = await response.json();
            fetchDiscoveredWallboxes();
        } catch (e) {
            console.error('Failed to select wallbox:', e);
            alert('Failed to select wallbox');
        }
    }

    async function toggleAutodiscovery() {
        const enabled = document.getElementById('autodiscovery-enabled').checked;

        try {
            const response = await fetch('/api/autodiscovery', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            });

            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            const result = await response.json();
        } catch (e) {
            console.error('Failed to toggle autodiscovery:', e);
            document.getElementById('autodiscovery-enabled').checked = !enabled;
        }
    }

    document.getElementById('autodiscovery-enabled').addEventListener('change', toggleAutodiscovery);

    setInterval(() => {
        fetchChargePoints();
        fetchTransactions();
        updateWallboxCapabilityStatus();
    }, 3000);
    setInterval(fetchServerSettings, 3000);
    setInterval(fetchDiscoveredWallboxes, 2000);

    fetchServerSettings();
    fetchAndRenderTestSteps();
    fetchDiscoveredWallboxes();
    fetchTransactions();

    updateWallboxCapabilityStatus();
    refreshEvStatus();
    connectEvStatusSocket();
    connectLogSocket();

    fetchChargePoints();

    document.addEventListener('DOMContentLoaded', (event) => {
        const modal = document.getElementById('chargingProfileModal');
        const closeButton = document.getElementById('modal-close-button');
        const form = document.getElementById('chargingProfileForm');

        closeButton.onclick = function() {
            modal.style.display = "none";
        }

        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }

        form.onsubmit = function(event) {
            event.preventDefault();
            const stepKey = document.getElementById('modal-step-key').value;
            const params = {
                stackLevel: parseInt(form.stackLevel.value),
                chargingProfilePurpose: form.chargingProfilePurpose.value,
                chargingProfileKind: form.chargingProfileKind.value,
                limit: parseFloat(form.limit.value),
                duration: parseInt(form.duration.value)
            };
            runTestWithParams(stepKey, params);
            modal.style.display = "none";
        }
    });
</script>
</body>
</html>